{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.ACCOUNT_ID_PREFIX = void 0;\n\nvar _util = require(\"@polkadot/util\");\n\nvar _utilCrypto = require(\"@polkadot/util-crypto\");\n\nvar _Base = _interopRequireDefault(require(\"../codec/Base\"));\n\nvar _AccountIndex = _interopRequireDefault(require(\"../generic/AccountIndex\"));\n\nvar _AccountId = _interopRequireDefault(require(\"./AccountId\")); // Copyright 2017-2020 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nconst ACCOUNT_ID_PREFIX = new Uint8Array([0xff]);\n/** @internal */\n\nexports.ACCOUNT_ID_PREFIX = ACCOUNT_ID_PREFIX;\n\nfunction decodeString(registry, value) {\n  const decoded = (0, _utilCrypto.decodeAddress)(value);\n  return decoded.length === 20 ? registry.createType('EthereumAccountId', decoded) : registry.createType('AccountIndex', (0, _util.u8aToBn)(decoded, true));\n}\n/** @internal */\n\n\nfunction decodeU8a(registry, value) {\n  // This allows us to instantiate an address with a raw publicKey. Do this first before\n  // we checking the first byte, otherwise we may split an already-existent valid address\n  if (value.length === 20) {\n    return registry.createType('EthereumAccountId', value);\n  } else if (value[0] === 0xff) {\n    return registry.createType('EthereumAccountId', value.subarray(1));\n  }\n\n  const [offset, length] = _AccountIndex.default.readLength(value);\n\n  return registry.createType('AccountIndex', (0, _util.u8aToBn)(value.subarray(offset, offset + length), true));\n}\n/**\n * @name LookupSource\n * @description\n * A wrapper around an EthereumAccountId and/or AccountIndex that is encoded with a prefix.\n * Since we are dealing with underlying publicKeys (or shorter encoded addresses),\n * we extend from Base with an AccountId/AccountIndex wrapper. Basically the Address\n * is encoded as `[ <prefix-byte>, ...publicKey/...bytes ]` as per spec\n */\n\n\nclass LookupSource extends _Base.default {\n  constructor(registry, value = new Uint8Array()) {\n    super(registry, LookupSource._decodeAddress(registry, value));\n  }\n  /** @internal */\n\n\n  static _decodeAddress(registry, value) {\n    if (value instanceof _AccountId.default || value instanceof _AccountIndex.default) {\n      return value;\n    } else if (value instanceof LookupSource) {\n      return value._raw;\n    } else if ((0, _util.isBn)(value) || (0, _util.isNumber)(value)) {\n      return registry.createType('AccountIndex', value);\n    } else if (Array.isArray(value) || (0, _util.isHex)(value) || (0, _util.isU8a)(value)) {\n      return decodeU8a(registry, (0, _util.u8aToU8a)(value));\n    }\n\n    return decodeString(registry, value);\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n\n\n  get encodedLength() {\n    const rawLength = this._rawLength;\n    return rawLength + ( // for 1 byte AccountIndexes, we are not adding a specific prefix\n    rawLength > 1 ? 1 : 0);\n  }\n  /**\n   * @description The length of the raw value, either AccountIndex or AccountId\n   */\n\n\n  get _rawLength() {\n    return this._raw instanceof _AccountIndex.default ? _AccountIndex.default.calcLength(this._raw) : this._raw.encodedLength;\n  }\n  /**\n   * @description Returns a hex string representation of the value\n   */\n\n\n  toHex() {\n    return (0, _util.u8aToHex)(this.toU8a());\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType() {\n    return 'Address';\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n\n\n  toU8a(isBare) {\n    const encoded = this._raw.toU8a().subarray(0, this._rawLength);\n\n    return isBare ? encoded : (0, _util.u8aConcat)(this._raw instanceof _AccountIndex.default ? _AccountIndex.default.writeLength(encoded) : ACCOUNT_ID_PREFIX, encoded);\n  }\n\n}\n\nexports.default = LookupSource;","map":{"version":3,"sources":["/home/robin/substrate-front-end-template/node_modules/@polkadot/types/ethereum/LookupSource.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","default","ACCOUNT_ID_PREFIX","_util","_utilCrypto","_Base","_AccountIndex","_AccountId","Uint8Array","decodeString","registry","decoded","decodeAddress","length","createType","u8aToBn","decodeU8a","subarray","offset","readLength","LookupSource","constructor","_decodeAddress","_raw","isBn","isNumber","Array","isArray","isHex","isU8a","u8aToU8a","encodedLength","rawLength","_rawLength","calcLength","toHex","u8aToHex","toU8a","toRawType","isBare","encoded","u8aConcat","writeLength"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.ACCOUNT_ID_PREFIX = void 0;\n\nvar _util = require(\"@polkadot/util\");\n\nvar _utilCrypto = require(\"@polkadot/util-crypto\");\n\nvar _Base = _interopRequireDefault(require(\"../codec/Base\"));\n\nvar _AccountIndex = _interopRequireDefault(require(\"../generic/AccountIndex\"));\n\nvar _AccountId = _interopRequireDefault(require(\"./AccountId\"));\n\n// Copyright 2017-2020 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nconst ACCOUNT_ID_PREFIX = new Uint8Array([0xff]);\n/** @internal */\n\nexports.ACCOUNT_ID_PREFIX = ACCOUNT_ID_PREFIX;\n\nfunction decodeString(registry, value) {\n  const decoded = (0, _utilCrypto.decodeAddress)(value);\n  return decoded.length === 20 ? registry.createType('EthereumAccountId', decoded) : registry.createType('AccountIndex', (0, _util.u8aToBn)(decoded, true));\n}\n/** @internal */\n\n\nfunction decodeU8a(registry, value) {\n  // This allows us to instantiate an address with a raw publicKey. Do this first before\n  // we checking the first byte, otherwise we may split an already-existent valid address\n  if (value.length === 20) {\n    return registry.createType('EthereumAccountId', value);\n  } else if (value[0] === 0xff) {\n    return registry.createType('EthereumAccountId', value.subarray(1));\n  }\n\n  const [offset, length] = _AccountIndex.default.readLength(value);\n\n  return registry.createType('AccountIndex', (0, _util.u8aToBn)(value.subarray(offset, offset + length), true));\n}\n/**\n * @name LookupSource\n * @description\n * A wrapper around an EthereumAccountId and/or AccountIndex that is encoded with a prefix.\n * Since we are dealing with underlying publicKeys (or shorter encoded addresses),\n * we extend from Base with an AccountId/AccountIndex wrapper. Basically the Address\n * is encoded as `[ <prefix-byte>, ...publicKey/...bytes ]` as per spec\n */\n\n\nclass LookupSource extends _Base.default {\n  constructor(registry, value = new Uint8Array()) {\n    super(registry, LookupSource._decodeAddress(registry, value));\n  }\n  /** @internal */\n\n\n  static _decodeAddress(registry, value) {\n    if (value instanceof _AccountId.default || value instanceof _AccountIndex.default) {\n      return value;\n    } else if (value instanceof LookupSource) {\n      return value._raw;\n    } else if ((0, _util.isBn)(value) || (0, _util.isNumber)(value)) {\n      return registry.createType('AccountIndex', value);\n    } else if (Array.isArray(value) || (0, _util.isHex)(value) || (0, _util.isU8a)(value)) {\n      return decodeU8a(registry, (0, _util.u8aToU8a)(value));\n    }\n\n    return decodeString(registry, value);\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n\n\n  get encodedLength() {\n    const rawLength = this._rawLength;\n    return rawLength + ( // for 1 byte AccountIndexes, we are not adding a specific prefix\n    rawLength > 1 ? 1 : 0);\n  }\n  /**\n   * @description The length of the raw value, either AccountIndex or AccountId\n   */\n\n\n  get _rawLength() {\n    return this._raw instanceof _AccountIndex.default ? _AccountIndex.default.calcLength(this._raw) : this._raw.encodedLength;\n  }\n  /**\n   * @description Returns a hex string representation of the value\n   */\n\n\n  toHex() {\n    return (0, _util.u8aToHex)(this.toU8a());\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType() {\n    return 'Address';\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n\n\n  toU8a(isBare) {\n    const encoded = this._raw.toU8a().subarray(0, this._rawLength);\n\n    return isBare ? encoded : (0, _util.u8aConcat)(this._raw instanceof _AccountIndex.default ? _AccountIndex.default.writeLength(encoded) : ACCOUNT_ID_PREFIX, encoded);\n  }\n\n}\n\nexports.default = LookupSource;"]},"metadata":{},"sourceType":"script"}