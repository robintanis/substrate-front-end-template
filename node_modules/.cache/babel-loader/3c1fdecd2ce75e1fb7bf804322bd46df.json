{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createTypeUnsafe = createTypeUnsafe;\nexports.createType = createType;\n\nvar _util = require(\"@polkadot/util\");\n\nvar _createClass = require(\"./createClass\"); // Copyright 2017-2020 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nfunction u8aHasValue(value) {\n  return value.some(v => !!v);\n} // With isPedantic, actually check that the encoding matches that supplied. This\n// is much slower, but verifies that we have the correct types defined\n\n\nfunction checkInstance(value, created) {\n  // the underlying type created.toRawType()\n  const rawType = created.toRawType(); // ignore bytes completely - this is probably a FIXME, since these are somewhat\n  // breaking for at least online queries - not quite sure wtf is going wrong here\n\n  if (rawType === 'Bytes') {\n    return;\n  } // the hex values for what we have\n\n\n  const inHex = (0, _util.u8aToHex)(value);\n  const crHex = created.toHex(); // Check equality, based on some different approaches (as decoded)\n\n  const isEqual = inHex === crHex || // raw hex values, quick path\n  inHex === created.toHex(true) || // wrapped options\n  (0, _util.u8aToHex)(value.reverse()) === crHex; // reverse (for numbers, which are BE)\n  // if the hex doesn't match and the value for both is non-empty, complain... bitterly\n\n  if (!isEqual && (u8aHasValue(value) || u8aHasValue(created.toU8a(true)))) {\n    console.warn(`${rawType}:: Input doesn't match output, received ${(0, _util.u8aToHex)(value)}, created ${crHex}`);\n  }\n} // Initializes a type with a value. This also checks for fallbacks and in the cases\n// where isPedantic is specified (storage decoding), also check the format/structure\n\n\nfunction initType(registry, Type, params = [], isPedantic) {\n  const created = new Type(registry, ...params); // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n\n  const [value] = params;\n\n  if (isPedantic && (0, _util.isU8a)(value)) {\n    checkInstance(value, created);\n  }\n\n  return created;\n} // An unsafe version of the `createType` below. It's unsafe because the `type`\n// argument here can be any string, which, when it cannot parse, will yield a\n// runtime error.\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\nfunction createTypeUnsafe(registry, type, params = [], isPedantic) {\n  try {\n    // Circle back to isPedantic when it handles all cases 100% - as of now,\n    // it provides false warning which is more hinderance than help\n    return initType(registry, (0, _createClass.createClass)(registry, type), params); // , isPedantic);\n  } catch (error) {\n    throw new Error(`createType(${type}):: ${error.message}`);\n  }\n}\n/**\n * Create an instance of a `type` with a given `params`.\n * @param type - A recognizable string representing the type to create an\n * instance from\n * @param params - The value to instantiate the type with\n */\n\n\nfunction createType(registry, type, ...params) {\n  return createTypeUnsafe(registry, type, params);\n}","map":{"version":3,"sources":["/home/robin/substrate-front-end-template/node_modules/@polkadot/types/create/createType.js"],"names":["Object","defineProperty","exports","value","createTypeUnsafe","createType","_util","require","_createClass","u8aHasValue","some","v","checkInstance","created","rawType","toRawType","inHex","u8aToHex","crHex","toHex","isEqual","reverse","toU8a","console","warn","initType","registry","Type","params","isPedantic","isU8a","type","createClass","error","Error","message"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createTypeUnsafe = createTypeUnsafe;\nexports.createType = createType;\n\nvar _util = require(\"@polkadot/util\");\n\nvar _createClass = require(\"./createClass\");\n\n// Copyright 2017-2020 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nfunction u8aHasValue(value) {\n  return value.some(v => !!v);\n} // With isPedantic, actually check that the encoding matches that supplied. This\n// is much slower, but verifies that we have the correct types defined\n\n\nfunction checkInstance(value, created) {\n  // the underlying type created.toRawType()\n  const rawType = created.toRawType(); // ignore bytes completely - this is probably a FIXME, since these are somewhat\n  // breaking for at least online queries - not quite sure wtf is going wrong here\n\n  if (rawType === 'Bytes') {\n    return;\n  } // the hex values for what we have\n\n\n  const inHex = (0, _util.u8aToHex)(value);\n  const crHex = created.toHex(); // Check equality, based on some different approaches (as decoded)\n\n  const isEqual = inHex === crHex || // raw hex values, quick path\n  inHex === created.toHex(true) || // wrapped options\n  (0, _util.u8aToHex)(value.reverse()) === crHex; // reverse (for numbers, which are BE)\n  // if the hex doesn't match and the value for both is non-empty, complain... bitterly\n\n  if (!isEqual && (u8aHasValue(value) || u8aHasValue(created.toU8a(true)))) {\n    console.warn(`${rawType}:: Input doesn't match output, received ${(0, _util.u8aToHex)(value)}, created ${crHex}`);\n  }\n} // Initializes a type with a value. This also checks for fallbacks and in the cases\n// where isPedantic is specified (storage decoding), also check the format/structure\n\n\nfunction initType(registry, Type, params = [], isPedantic) {\n  const created = new Type(registry, ...params); // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n\n  const [value] = params;\n\n  if (isPedantic && (0, _util.isU8a)(value)) {\n    checkInstance(value, created);\n  }\n\n  return created;\n} // An unsafe version of the `createType` below. It's unsafe because the `type`\n// argument here can be any string, which, when it cannot parse, will yield a\n// runtime error.\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\nfunction createTypeUnsafe(registry, type, params = [], isPedantic) {\n  try {\n    // Circle back to isPedantic when it handles all cases 100% - as of now,\n    // it provides false warning which is more hinderance than help\n    return initType(registry, (0, _createClass.createClass)(registry, type), params); // , isPedantic);\n  } catch (error) {\n    throw new Error(`createType(${type}):: ${error.message}`);\n  }\n}\n/**\n * Create an instance of a `type` with a given `params`.\n * @param type - A recognizable string representing the type to create an\n * instance from\n * @param params - The value to instantiate the type with\n */\n\n\nfunction createType(registry, type, ...params) {\n  return createTypeUnsafe(registry, type, params);\n}"]},"metadata":{},"sourceType":"script"}