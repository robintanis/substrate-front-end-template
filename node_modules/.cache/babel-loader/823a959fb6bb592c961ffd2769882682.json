{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = createPair;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _util = require(\"@polkadot/util\");\n\nvar _utilCrypto = require(\"@polkadot/util-crypto\");\n\nvar _decode = _interopRequireDefault(require(\"./decode\"));\n\nvar _encode = _interopRequireDefault(require(\"./encode\"));\n\nvar _toJson = _interopRequireDefault(require(\"./toJson\"));\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2.default)(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nconst SIG_TYPE_NONE = new Uint8Array();\nconst TYPE_FROM_SEED = {\n  ecdsa: _utilCrypto.secp256k1KeypairFromSeed,\n  ed25519: _utilCrypto.naclKeypairFromSeed,\n  ethereum: _utilCrypto.secp256k1KeypairFromSeed,\n  sr25519: _utilCrypto.schnorrkelKeypairFromSeed\n};\nconst TYPE_PREFIX = {\n  ecdsa: new Uint8Array([2]),\n  ed25519: new Uint8Array([0]),\n  ethereum: new Uint8Array([2]),\n  sr25519: new Uint8Array([1])\n};\nconst TYPE_SIGNATURE = {\n  ecdsa: (m, p) => (0, _utilCrypto.secp256k1Sign)(m, p, 'blake2'),\n  ed25519: _utilCrypto.naclSign,\n  ethereum: (m, p) => (0, _utilCrypto.secp256k1Sign)(m, p, 'keccak'),\n  sr25519: _utilCrypto.schnorrkelSign\n};\nconst TYPE_ADDRESS = {\n  ecdsa: p => p.length > 32 ? (0, _utilCrypto.blake2AsU8a)(p) : p,\n  ed25519: p => p,\n  ethereum: p => (0, _utilCrypto.keccakAsU8a)((0, _utilCrypto.secp256k1Expand)(p)),\n  sr25519: p => p\n};\nconst TYPE_VERIFY = {\n  ecdsa: (m, s, p) => (0, _utilCrypto.secp256k1Verify)(m, s, TYPE_ADDRESS.ecdsa(p), 'blake2'),\n  ed25519: _utilCrypto.naclVerify,\n  ethereum: (m, s, p) => (0, _utilCrypto.secp256k1Verify)(m, s, TYPE_ADDRESS.ethereum(p), 'keccak', true),\n  sr25519: _utilCrypto.schnorrkelVerify\n};\n\nfunction isEmpty(u8a) {\n  return u8a.reduce((count, u8) => count + u8, 0) === 0;\n} // Not 100% correct, since it can be a Uint8Array, but an invalid one - just say \"undefined\" is anything non-valid\n\n\nfunction isLocked(secretKey) {\n  return !secretKey || secretKey.length === 0 || isEmpty(secretKey);\n}\n/**\n * @name pair\n * @summary Creates a keyring pair object\n * @description Creates a keyring pair object with provided account public key, metadata, and encoded arguments.\n * The keyring pair stores the account state including the encoded address and associated metadata.\n *\n * It has properties whose values are functions that may be called to perform account actions:\n *\n * - `address` function retrieves the address associated with the account.\n * - `decodedPkcs8` function is called with the account passphrase and account encoded public key.\n * It decodes the encoded public key using the passphrase provided to obtain the decoded account public key\n * and associated secret key that are then available in memory, and changes the account address stored in the\n * state of the pair to correspond to the address of the decoded public key.\n * - `encodePkcs8` function when provided with the correct passphrase associated with the account pair\n * and when the secret key is in memory (when the account pair is not locked) it returns an encoded\n * public key of the account.\n * - `meta` is the metadata that is stored in the state of the pair, either when it was originally\n * created or set via `setMeta`.\n * - `publicKey` returns the public key stored in memory for the pair.\n * - `sign` may be used to return a signature by signing a provided message with the secret\n * key (if it is in memory) using Nacl.\n * - `toJson` calls another `toJson` function and provides the state of the pair,\n * it generates arguments to be passed to the other `toJson` function including an encoded public key of the account\n * that it generates using the secret key from memory (if it has been made available in memory)\n * and the optionally provided passphrase argument. It passes a third boolean argument to `toJson`\n * indicating whether the public key has been encoded or not (if a passphrase argument was provided then it is encoded).\n * The `toJson` function that it calls returns a JSON object with properties including the `address`\n * and `meta` that are assigned with the values stored in the corresponding state variables of the account pair,\n * an `encoded` property that is assigned with the encoded public key in hex format, and an `encoding`\n * property that indicates whether the public key value of the `encoded` property is encoded or not.\n */\n\n\nfunction createPair({\n  toSS58,\n  type\n}, {\n  publicKey,\n  secretKey\n}, meta = {}, encoded = null, encTypes) {\n  const decodePkcs8 = (passphrase, userEncoded) => {\n    const decoded = (0, _decode.default)(passphrase, userEncoded || encoded, encTypes);\n\n    if (decoded.secretKey.length === 64) {\n      publicKey = decoded.publicKey;\n      secretKey = decoded.secretKey;\n    } else {\n      const pair = TYPE_FROM_SEED[type](decoded.secretKey);\n      publicKey = pair.publicKey;\n      secretKey = pair.secretKey;\n    }\n  };\n\n  const recode = passphrase => {\n    isLocked(secretKey) && encoded && decodePkcs8(passphrase, encoded);\n    encoded = (0, _encode.default)({\n      publicKey,\n      secretKey\n    }, passphrase); // re-encode, latest version\n\n    encTypes = undefined; // swap to defaults, latest version follows\n\n    return encoded;\n  };\n\n  const encodeAddress = () => {\n    const raw = TYPE_ADDRESS[type](publicKey);\n    return type === 'ethereum' ? (0, _utilCrypto.ethereumEncode)(raw) : toSS58(raw);\n  };\n\n  return {\n    get address() {\n      return encodeAddress();\n    },\n\n    get addressRaw() {\n      const raw = TYPE_ADDRESS[type](publicKey);\n      return type === 'ethereum' ? raw.slice(-20) : raw;\n    },\n\n    get isLocked() {\n      return isLocked(secretKey);\n    },\n\n    get meta() {\n      return meta;\n    },\n\n    get publicKey() {\n      return publicKey;\n    },\n\n    get type() {\n      return type;\n    },\n\n    // eslint-disable-next-line sort-keys\n    decodePkcs8,\n    derive: (suri, meta) => {\n      (0, _util.assert)(!isLocked(secretKey), 'Cannot derive on a locked keypair');\n      const {\n        path\n      } = (0, _utilCrypto.keyExtractPath)(suri);\n      const derived = (0, _utilCrypto.keyFromPath)({\n        publicKey,\n        secretKey\n      }, path, type);\n      return createPair({\n        toSS58,\n        type\n      }, derived, meta, null);\n    },\n    encodePkcs8: passphrase => recode(passphrase),\n    lock: () => {\n      secretKey = new Uint8Array();\n    },\n    setMeta: additional => {\n      meta = _objectSpread(_objectSpread({}, meta), additional);\n    },\n    sign: (message, options = {}) => {\n      (0, _util.assert)(!isLocked(secretKey), 'Cannot sign with a locked key pair');\n      return (0, _util.u8aConcat)(options.withType ? TYPE_PREFIX[type] : SIG_TYPE_NONE, TYPE_SIGNATURE[type](message, {\n        publicKey,\n        secretKey\n      }));\n    },\n    toJson: passphrase => {\n      const address = ['ecdsa', 'ethereum'].includes(type) ? (0, _util.u8aToHex)((0, _utilCrypto.secp256k1Compress)(publicKey)) : encodeAddress();\n      return (0, _toJson.default)(type, {\n        address,\n        meta\n      }, recode(passphrase), !!passphrase);\n    },\n    verify: (message, signature) => TYPE_VERIFY[type](message, signature, publicKey)\n  };\n}","map":{"version":3,"sources":["/home/robin/substrate-front-end-template/node_modules/@polkadot/keyring/pair/index.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","default","createPair","_defineProperty2","_util","_utilCrypto","_decode","_encode","_toJson","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","SIG_TYPE_NONE","Uint8Array","TYPE_FROM_SEED","ecdsa","secp256k1KeypairFromSeed","ed25519","naclKeypairFromSeed","ethereum","sr25519","schnorrkelKeypairFromSeed","TYPE_PREFIX","TYPE_SIGNATURE","m","p","secp256k1Sign","naclSign","schnorrkelSign","TYPE_ADDRESS","blake2AsU8a","keccakAsU8a","secp256k1Expand","TYPE_VERIFY","s","secp256k1Verify","naclVerify","schnorrkelVerify","isEmpty","u8a","reduce","count","u8","isLocked","secretKey","toSS58","type","publicKey","meta","encoded","encTypes","decodePkcs8","passphrase","userEncoded","decoded","pair","recode","undefined","encodeAddress","raw","ethereumEncode","address","addressRaw","slice","derive","suri","assert","path","keyExtractPath","derived","keyFromPath","encodePkcs8","lock","setMeta","additional","sign","message","options","u8aConcat","withType","toJson","includes","u8aToHex","secp256k1Compress","verify","signature"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = createPair;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _util = require(\"@polkadot/util\");\n\nvar _utilCrypto = require(\"@polkadot/util-crypto\");\n\nvar _decode = _interopRequireDefault(require(\"./decode\"));\n\nvar _encode = _interopRequireDefault(require(\"./encode\"));\n\nvar _toJson = _interopRequireDefault(require(\"./toJson\"));\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nconst SIG_TYPE_NONE = new Uint8Array();\nconst TYPE_FROM_SEED = {\n  ecdsa: _utilCrypto.secp256k1KeypairFromSeed,\n  ed25519: _utilCrypto.naclKeypairFromSeed,\n  ethereum: _utilCrypto.secp256k1KeypairFromSeed,\n  sr25519: _utilCrypto.schnorrkelKeypairFromSeed\n};\nconst TYPE_PREFIX = {\n  ecdsa: new Uint8Array([2]),\n  ed25519: new Uint8Array([0]),\n  ethereum: new Uint8Array([2]),\n  sr25519: new Uint8Array([1])\n};\nconst TYPE_SIGNATURE = {\n  ecdsa: (m, p) => (0, _utilCrypto.secp256k1Sign)(m, p, 'blake2'),\n  ed25519: _utilCrypto.naclSign,\n  ethereum: (m, p) => (0, _utilCrypto.secp256k1Sign)(m, p, 'keccak'),\n  sr25519: _utilCrypto.schnorrkelSign\n};\nconst TYPE_ADDRESS = {\n  ecdsa: p => p.length > 32 ? (0, _utilCrypto.blake2AsU8a)(p) : p,\n  ed25519: p => p,\n  ethereum: p => (0, _utilCrypto.keccakAsU8a)((0, _utilCrypto.secp256k1Expand)(p)),\n  sr25519: p => p\n};\nconst TYPE_VERIFY = {\n  ecdsa: (m, s, p) => (0, _utilCrypto.secp256k1Verify)(m, s, TYPE_ADDRESS.ecdsa(p), 'blake2'),\n  ed25519: _utilCrypto.naclVerify,\n  ethereum: (m, s, p) => (0, _utilCrypto.secp256k1Verify)(m, s, TYPE_ADDRESS.ethereum(p), 'keccak', true),\n  sr25519: _utilCrypto.schnorrkelVerify\n};\n\nfunction isEmpty(u8a) {\n  return u8a.reduce((count, u8) => count + u8, 0) === 0;\n} // Not 100% correct, since it can be a Uint8Array, but an invalid one - just say \"undefined\" is anything non-valid\n\n\nfunction isLocked(secretKey) {\n  return !secretKey || secretKey.length === 0 || isEmpty(secretKey);\n}\n/**\n * @name pair\n * @summary Creates a keyring pair object\n * @description Creates a keyring pair object with provided account public key, metadata, and encoded arguments.\n * The keyring pair stores the account state including the encoded address and associated metadata.\n *\n * It has properties whose values are functions that may be called to perform account actions:\n *\n * - `address` function retrieves the address associated with the account.\n * - `decodedPkcs8` function is called with the account passphrase and account encoded public key.\n * It decodes the encoded public key using the passphrase provided to obtain the decoded account public key\n * and associated secret key that are then available in memory, and changes the account address stored in the\n * state of the pair to correspond to the address of the decoded public key.\n * - `encodePkcs8` function when provided with the correct passphrase associated with the account pair\n * and when the secret key is in memory (when the account pair is not locked) it returns an encoded\n * public key of the account.\n * - `meta` is the metadata that is stored in the state of the pair, either when it was originally\n * created or set via `setMeta`.\n * - `publicKey` returns the public key stored in memory for the pair.\n * - `sign` may be used to return a signature by signing a provided message with the secret\n * key (if it is in memory) using Nacl.\n * - `toJson` calls another `toJson` function and provides the state of the pair,\n * it generates arguments to be passed to the other `toJson` function including an encoded public key of the account\n * that it generates using the secret key from memory (if it has been made available in memory)\n * and the optionally provided passphrase argument. It passes a third boolean argument to `toJson`\n * indicating whether the public key has been encoded or not (if a passphrase argument was provided then it is encoded).\n * The `toJson` function that it calls returns a JSON object with properties including the `address`\n * and `meta` that are assigned with the values stored in the corresponding state variables of the account pair,\n * an `encoded` property that is assigned with the encoded public key in hex format, and an `encoding`\n * property that indicates whether the public key value of the `encoded` property is encoded or not.\n */\n\n\nfunction createPair({\n  toSS58,\n  type\n}, {\n  publicKey,\n  secretKey\n}, meta = {}, encoded = null, encTypes) {\n  const decodePkcs8 = (passphrase, userEncoded) => {\n    const decoded = (0, _decode.default)(passphrase, userEncoded || encoded, encTypes);\n\n    if (decoded.secretKey.length === 64) {\n      publicKey = decoded.publicKey;\n      secretKey = decoded.secretKey;\n    } else {\n      const pair = TYPE_FROM_SEED[type](decoded.secretKey);\n      publicKey = pair.publicKey;\n      secretKey = pair.secretKey;\n    }\n  };\n\n  const recode = passphrase => {\n    isLocked(secretKey) && encoded && decodePkcs8(passphrase, encoded);\n    encoded = (0, _encode.default)({\n      publicKey,\n      secretKey\n    }, passphrase); // re-encode, latest version\n\n    encTypes = undefined; // swap to defaults, latest version follows\n\n    return encoded;\n  };\n\n  const encodeAddress = () => {\n    const raw = TYPE_ADDRESS[type](publicKey);\n    return type === 'ethereum' ? (0, _utilCrypto.ethereumEncode)(raw) : toSS58(raw);\n  };\n\n  return {\n    get address() {\n      return encodeAddress();\n    },\n\n    get addressRaw() {\n      const raw = TYPE_ADDRESS[type](publicKey);\n      return type === 'ethereum' ? raw.slice(-20) : raw;\n    },\n\n    get isLocked() {\n      return isLocked(secretKey);\n    },\n\n    get meta() {\n      return meta;\n    },\n\n    get publicKey() {\n      return publicKey;\n    },\n\n    get type() {\n      return type;\n    },\n\n    // eslint-disable-next-line sort-keys\n    decodePkcs8,\n    derive: (suri, meta) => {\n      (0, _util.assert)(!isLocked(secretKey), 'Cannot derive on a locked keypair');\n      const {\n        path\n      } = (0, _utilCrypto.keyExtractPath)(suri);\n      const derived = (0, _utilCrypto.keyFromPath)({\n        publicKey,\n        secretKey\n      }, path, type);\n      return createPair({\n        toSS58,\n        type\n      }, derived, meta, null);\n    },\n    encodePkcs8: passphrase => recode(passphrase),\n    lock: () => {\n      secretKey = new Uint8Array();\n    },\n    setMeta: additional => {\n      meta = _objectSpread(_objectSpread({}, meta), additional);\n    },\n    sign: (message, options = {}) => {\n      (0, _util.assert)(!isLocked(secretKey), 'Cannot sign with a locked key pair');\n      return (0, _util.u8aConcat)(options.withType ? TYPE_PREFIX[type] : SIG_TYPE_NONE, TYPE_SIGNATURE[type](message, {\n        publicKey,\n        secretKey\n      }));\n    },\n    toJson: passphrase => {\n      const address = ['ecdsa', 'ethereum'].includes(type) ? (0, _util.u8aToHex)((0, _utilCrypto.secp256k1Compress)(publicKey)) : encodeAddress();\n      return (0, _toJson.default)(type, {\n        address,\n        meta\n      }, recode(passphrase), !!passphrase);\n    },\n    verify: (message, signature) => TYPE_VERIFY[type](message, signature, publicKey)\n  };\n}"]},"metadata":{},"sourceType":"script"}