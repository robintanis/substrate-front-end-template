{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _classPrivateFieldLooseBase2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classPrivateFieldLooseBase\"));\n\nvar _classPrivateFieldLooseKey2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classPrivateFieldLooseKey\"));\n\nvar _rxjs = require(\"rxjs\");\n\nvar _operators = require(\"rxjs/operators\");\n\nvar _types = require(\"@polkadot/types\");\n\nvar _Extrinsic = require(\"@polkadot/types/extrinsic/Extrinsic\");\n\nvar _typesKnown = require(\"@polkadot/types-known\");\n\nvar _util = require(\"@polkadot/util\");\n\nvar _utilCrypto = require(\"@polkadot/util-crypto\");\n\nvar _Decorate = _interopRequireDefault(require(\"./Decorate\")); // Copyright 2017-2020 @polkadot/api authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nconst KEEPALIVE_INTERVAL = 15000;\nconst DEFAULT_BLOCKNUMBER = {\n  unwrap: () => _util.BN_ZERO\n};\nconst l = (0, _util.logger)('api/init');\n\nvar _healthTimer = (0, _classPrivateFieldLooseKey2.default)(\"healthTimer\");\n\nvar _registries = (0, _classPrivateFieldLooseKey2.default)(\"registries\");\n\nvar _updateSub = (0, _classPrivateFieldLooseKey2.default)(\"updateSub\");\n\nvar _onProviderConnect = (0, _classPrivateFieldLooseKey2.default)(\"onProviderConnect\");\n\nvar _onProviderDisconnect = (0, _classPrivateFieldLooseKey2.default)(\"onProviderDisconnect\");\n\nvar _onProviderError = (0, _classPrivateFieldLooseKey2.default)(\"onProviderError\");\n\nclass Init extends _Decorate.default {\n  constructor(options, type, decorateMethod) {\n    super(options, type, decorateMethod);\n    Object.defineProperty(this, _healthTimer, {\n      writable: true,\n      value: null\n    });\n    Object.defineProperty(this, _registries, {\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, _updateSub, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _onProviderConnect, {\n      writable: true,\n      value: async () => {\n        this.emit('connected');\n\n        this._isConnected.next(true);\n\n        try {\n          const [hasMeta, cryptoReady] = await Promise.all([this._loadMeta(), this._options.initWasm === false ? Promise.resolve(true) : (0, _utilCrypto.cryptoWaitReady)()]);\n\n          if (hasMeta && !this._isReady && cryptoReady) {\n            this._isReady = true;\n            this.emit('ready', this);\n          }\n\n          (0, _classPrivateFieldLooseBase2.default)(this, _healthTimer)[_healthTimer] = setInterval(() => {\n            this._rpcCore.system.health().toPromise().catch(() => {// ignore\n            });\n          }, KEEPALIVE_INTERVAL);\n        } catch (_error) {\n          const error = new Error(`FATAL: Unable to initialize the API: ${_error.message}`);\n          l.error(error);\n          this.emit('error', error);\n        }\n      }\n    });\n    Object.defineProperty(this, _onProviderDisconnect, {\n      writable: true,\n      value: () => {\n        this.emit('disconnected');\n\n        this._isConnected.next(false);\n\n        if ((0, _classPrivateFieldLooseBase2.default)(this, _healthTimer)[_healthTimer]) {\n          clearInterval((0, _classPrivateFieldLooseBase2.default)(this, _healthTimer)[_healthTimer]);\n          (0, _classPrivateFieldLooseBase2.default)(this, _healthTimer)[_healthTimer] = null;\n        }\n      }\n    });\n    Object.defineProperty(this, _onProviderError, {\n      writable: true,\n      value: error => {\n        this.emit('error', error);\n      }\n    });\n\n    if (!this.hasSubscriptions) {\n      l.warn('Api will be available in a limited mode since the provider does not support subscriptions');\n    } // all injected types added to the registry for overrides\n\n\n    this.registry.setKnownTypes(options); // We only register the types (global) if this is not a cloned instance.\n    // Do right up-front, so we get in the user types before we are actually\n    // doing anything on-chain, this ensures we have the overrides in-place\n\n    if (!options.source) {\n      this.registerTypes(options.types);\n    } else {\n      (0, _classPrivateFieldLooseBase2.default)(this, _registries)[_registries] = (0, _classPrivateFieldLooseBase2.default)(options.source, _registries)[_registries];\n    }\n\n    this._rpc = this._decorateRpc(this._rpcCore, this._decorateMethod);\n    this._rx.rpc = this._decorateRpc(this._rpcCore, this._rxDecorateMethod);\n    this._queryMulti = this._decorateMulti(this._decorateMethod);\n    this._rx.queryMulti = this._decorateMulti(this._rxDecorateMethod);\n    this._rx.signer = options.signer;\n\n    this._rpcCore.setRegistrySwap(hash => this.getBlockRegistry(hash));\n\n    this._rpcCore.provider.on('disconnected', (0, _classPrivateFieldLooseBase2.default)(this, _onProviderDisconnect)[_onProviderDisconnect]);\n\n    this._rpcCore.provider.on('error', (0, _classPrivateFieldLooseBase2.default)(this, _onProviderError)[_onProviderError]);\n\n    this._rpcCore.provider.on('connected', (0, _classPrivateFieldLooseBase2.default)(this, _onProviderConnect)[_onProviderConnect]); // If the provider was instantiated earlier, and has already emitted a\n    // 'connected' event, then the `on('connected')` won't fire anymore. To\n    // cater for this case, we call manually `this._onProviderConnect`.\n\n\n    if (this._rpcCore.provider.isConnected) {\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      (0, _classPrivateFieldLooseBase2.default)(this, _onProviderConnect)[_onProviderConnect]();\n    }\n  }\n  /**\n   * @description Decorates a registry based on the runtime version\n   */\n\n\n  _initRegistry(registry, chain, version, chainProps) {\n    registry.setChainProperties(chainProps || this.registry.getChainProperties());\n    registry.setKnownTypes(this._options);\n    registry.register((0, _typesKnown.getSpecTypes)(registry, chain, version.specName, version.specVersion)); // for bundled types, pull through the aliasses defined\n\n    if (registry.knownTypes.typesBundle) {\n      registry.knownTypes.typesAlias = (0, _typesKnown.getSpecAlias)(registry, chain, version.specName);\n    }\n\n    return registry;\n  }\n  /**\n   * @description Sets up a registry based on the block hash defined\n   */\n\n\n  async getBlockRegistry(blockHash) {\n    // shortcut in the case where we have an immediate-same request\n    const lastBlockHash = (0, _util.u8aToU8a)(blockHash);\n\n    const existingViaHash = (0, _classPrivateFieldLooseBase2.default)(this, _registries)[_registries].find(r => r.lastBlockHash && (0, _util.u8aEq)(lastBlockHash, r.lastBlockHash));\n\n    if (existingViaHash) {\n      return existingViaHash;\n    } // ensure we have everything required\n\n\n    (0, _util.assert)(this._genesisHash && this._runtimeVersion, 'Cannot retrieve data on an uninitialized chain'); // We have to assume that on the RPC layer the calls used here does not call back into\n    // the registry swap, so getHeader & getRuntimeVersion should not be historic\n\n    const header = this._genesisHash.eq(blockHash) ? {\n      number: DEFAULT_BLOCKNUMBER,\n      parentHash: this._genesisHash\n    } : await this._rpcCore.chain.getHeader(blockHash).toPromise();\n    (0, _util.assert)((header === null || header === void 0 ? void 0 : header.parentHash) && !header.parentHash.isEmpty, 'Unable to retrieve header and parent from supplied hash'); // get the runtime version, either on-chain or via an known upgrade history\n\n    const [firstVersion, lastVersion] = (0, _typesKnown.getUpgradeVersion)(this._genesisHash, header.number.unwrap());\n    const version = firstVersion && (lastVersion || firstVersion.specVersion.eq(this._runtimeVersion.specVersion)) ? {\n      specName: this._runtimeVersion.specName,\n      specVersion: firstVersion.specVersion\n    } : await this._rpcCore.state.getRuntimeVersion(header.parentHash).toPromise(); // check for pre-existing registries\n\n    const existingViaVersion = (0, _classPrivateFieldLooseBase2.default)(this, _registries)[_registries].find(r => r.specVersion.eq(version.specVersion));\n\n    if (existingViaVersion) {\n      existingViaVersion.lastBlockHash = lastBlockHash;\n      return existingViaVersion;\n    } // nothing has been found, construct new\n\n\n    const registry = this._initRegistry(new _types.TypeRegistry(), this._runtimeChain, version);\n\n    const metadata = await this._rpcCore.state.getMetadata(header.parentHash).toPromise();\n    const result = {\n      isDefault: false,\n      lastBlockHash,\n      metadata,\n      metadataConsts: null,\n      registry,\n      specVersion: version.specVersion\n    };\n    registry.setMetadata(metadata);\n\n    (0, _classPrivateFieldLooseBase2.default)(this, _registries)[_registries].push(result);\n\n    return result;\n  }\n\n  async _loadMeta() {\n    var _this$_options$source;\n\n    const genesisHash = await this._rpcCore.chain.getBlockHash(0).toPromise(); // on re-connection to the same chain, we don't want to re-do everything from chain again\n\n    if (this._isReady && !this._options.source && genesisHash.eq(this._genesisHash)) {\n      return true;\n    }\n\n    if (this._genesisHash) {\n      l.warn('Connection to new genesis detected, re-initializing');\n    }\n\n    this._genesisHash = genesisHash;\n\n    if ((0, _classPrivateFieldLooseBase2.default)(this, _updateSub)[_updateSub]) {\n      (0, _classPrivateFieldLooseBase2.default)(this, _updateSub)[_updateSub].unsubscribe();\n    }\n\n    const {\n      metadata = {}\n    } = this._options; // only load from on-chain if we are not a clone (default path), alternatively\n    // just use the values from the source instance provided\n\n    this._runtimeMetadata = ((_this$_options$source = this._options.source) === null || _this$_options$source === void 0 ? void 0 : _this$_options$source._isReady) ? await this._metaFromSource(this._options.source) : await this._metaFromChain(metadata);\n    return this._initFromMeta(this._runtimeMetadata);\n  } // eslint-disable-next-line @typescript-eslint/require-await\n\n\n  async _metaFromSource(source) {\n    this._extrinsicType = source.extrinsicVersion;\n    this._runtimeChain = source.runtimeChain;\n    this._runtimeVersion = source.runtimeVersion;\n    this._genesisHash = source.genesisHash;\n    const methods = []; // manually build a list of all available methods in this RPC, we are\n    // going to filter on it to align the cloned RPC without making a call\n\n    Object.keys(source.rpc).forEach(section => {\n      Object.keys(source.rpc[section]).forEach(method => {\n        methods.push(`${section}_${method}`);\n      });\n    });\n\n    this._filterRpcMethods(methods);\n\n    return source.runtimeMetadata;\n  } // subscribe to metadata updates, inject the types on changes\n\n\n  _subscribeUpdates() {\n    if ((0, _classPrivateFieldLooseBase2.default)(this, _updateSub)[_updateSub] || !this.hasSubscriptions) {\n      return;\n    }\n\n    (0, _classPrivateFieldLooseBase2.default)(this, _updateSub)[_updateSub] = this._rpcCore.state.subscribeRuntimeVersion().pipe((0, _operators.switchMap)(version => {\n      var _this$_runtimeVersion;\n\n      return (// only retrieve the metadata when the on-chain version has been changed\n        ((_this$_runtimeVersion = this._runtimeVersion) === null || _this$_runtimeVersion === void 0 ? void 0 : _this$_runtimeVersion.specVersion.eq(version.specVersion)) ? (0, _rxjs.of)(false) : this._rpcCore.state.getMetadata().pipe((0, _operators.map)(metadata => {\n          l.log(`Runtime version updated to spec=${version.specVersion.toString()}, tx=${version.transactionVersion.toString()}`);\n          this._runtimeMetadata = metadata;\n          this._runtimeVersion = version;\n          this._rx.runtimeVersion = version; // update the default registry version\n\n          const thisRegistry = (0, _classPrivateFieldLooseBase2.default)(this, _registries)[_registries].find(({\n            isDefault\n          }) => isDefault);\n\n          (0, _util.assert)(thisRegistry, 'Initialization error, cannot find the default registry'); // setup the data as per the current versions\n\n          thisRegistry.metadata = metadata;\n          thisRegistry.metadataConsts = null;\n          thisRegistry.registry.setMetadata(metadata);\n          thisRegistry.specVersion = version.specVersion; // clear the registry types to ensure that we override correctly\n\n          this._initRegistry(thisRegistry.registry.init(), this._runtimeChain, version);\n\n          this.injectMetadata(metadata, false, thisRegistry.registry);\n          return true;\n        }))\n      );\n    })).subscribe();\n  }\n\n  async _metaFromChain(optMetadata) {\n    var _this$_genesisHash;\n\n    const [runtimeVersion, chain, chainProps] = await Promise.all([this._rpcCore.state.getRuntimeVersion().toPromise(), this._rpcCore.system.chain().toPromise(), this._rpcCore.system.properties().toPromise()]); // set our chain version & genesisHash as returned\n\n    this._runtimeChain = chain;\n    this._runtimeVersion = runtimeVersion;\n    this._rx.runtimeVersion = runtimeVersion; // initializes the registry\n\n    this._initRegistry(this.registry, chain, runtimeVersion, chainProps);\n\n    this._subscribeUpdates(); // filter the RPC methods (this does an rpc-methods call)\n\n\n    await this._filterRpc(); // retrieve metadata, either from chain  or as pass-in via options\n\n    const metadataKey = `${((_this$_genesisHash = this._genesisHash) === null || _this$_genesisHash === void 0 ? void 0 : _this$_genesisHash.toHex()) || '0x'}-${runtimeVersion.specVersion.toString()}`;\n    const metadata = metadataKey in optMetadata ? new _types.Metadata(this.registry, optMetadata[metadataKey]) : await this._rpcCore.state.getMetadata().toPromise();\n    this.registry.setMetadata(metadata); // setup the initial registry, when we have none\n\n    if (!(0, _classPrivateFieldLooseBase2.default)(this, _registries)[_registries].length) {\n      (0, _classPrivateFieldLooseBase2.default)(this, _registries)[_registries].push({\n        isDefault: true,\n        lastBlockHash: null,\n        metadata,\n        metadataConsts: null,\n        registry: this.registry,\n        specVersion: runtimeVersion.specVersion\n      });\n    } // get unique types & validate\n\n\n    metadata.getUniqTypes(false);\n    return metadata;\n  }\n\n  async _initFromMeta(metadata) {\n    const metaExtrinsic = metadata.asLatest.extrinsic; // only inject if we are not a clone (global init)\n\n    if (metaExtrinsic.version.gt(_util.BN_ZERO)) {\n      this._extrinsicType = metaExtrinsic.version.toNumber();\n    } else if (!this._options.source) {\n      // detect the extrinsic version in-use based on the last block\n      const {\n        block: {\n          extrinsics: [firstTx]\n        }\n      } = await this._rpcCore.chain.getBlock().toPromise(); // If we haven't sync-ed to 1 yes, this won't have any values\n\n      this._extrinsicType = firstTx ? firstTx.type : _Extrinsic.LATEST_EXTRINSIC_VERSION;\n    }\n\n    this._rx.extrinsicType = this._extrinsicType;\n    this._rx.genesisHash = this._genesisHash;\n    this._rx.runtimeVersion = this._runtimeVersion;\n    this.injectMetadata(metadata, true); // derive is last, since it uses the decorated rx\n\n    this._rx.derive = this._decorateDeriveRx(this._rxDecorateMethod);\n    this._derive = this._decorateDerive(this._decorateMethod);\n    return true;\n  }\n\n}\n\nexports.default = Init;","map":{"version":3,"sources":["/home/robin/substrate-front-end-template/node_modules/@polkadot/api/base/Init.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","default","_classPrivateFieldLooseBase2","_classPrivateFieldLooseKey2","_rxjs","_operators","_types","_Extrinsic","_typesKnown","_util","_utilCrypto","_Decorate","KEEPALIVE_INTERVAL","DEFAULT_BLOCKNUMBER","unwrap","BN_ZERO","l","logger","_healthTimer","_registries","_updateSub","_onProviderConnect","_onProviderDisconnect","_onProviderError","Init","constructor","options","type","decorateMethod","writable","emit","_isConnected","next","hasMeta","cryptoReady","Promise","all","_loadMeta","_options","initWasm","resolve","cryptoWaitReady","_isReady","setInterval","_rpcCore","system","health","toPromise","catch","_error","error","Error","message","clearInterval","hasSubscriptions","warn","registry","setKnownTypes","source","registerTypes","types","_rpc","_decorateRpc","_decorateMethod","_rx","rpc","_rxDecorateMethod","_queryMulti","_decorateMulti","queryMulti","signer","setRegistrySwap","hash","getBlockRegistry","provider","on","isConnected","_initRegistry","chain","version","chainProps","setChainProperties","getChainProperties","register","getSpecTypes","specName","specVersion","knownTypes","typesBundle","typesAlias","getSpecAlias","blockHash","lastBlockHash","u8aToU8a","existingViaHash","find","r","u8aEq","assert","_genesisHash","_runtimeVersion","header","eq","number","parentHash","getHeader","isEmpty","firstVersion","lastVersion","getUpgradeVersion","state","getRuntimeVersion","existingViaVersion","TypeRegistry","_runtimeChain","metadata","getMetadata","result","isDefault","metadataConsts","setMetadata","push","_this$_options$source","genesisHash","getBlockHash","unsubscribe","_runtimeMetadata","_metaFromSource","_metaFromChain","_initFromMeta","_extrinsicType","extrinsicVersion","runtimeChain","runtimeVersion","methods","keys","forEach","section","method","_filterRpcMethods","runtimeMetadata","_subscribeUpdates","subscribeRuntimeVersion","pipe","switchMap","_this$_runtimeVersion","of","map","log","toString","transactionVersion","thisRegistry","init","injectMetadata","subscribe","optMetadata","_this$_genesisHash","properties","_filterRpc","metadataKey","toHex","Metadata","length","getUniqTypes","metaExtrinsic","asLatest","extrinsic","gt","toNumber","block","extrinsics","firstTx","getBlock","LATEST_EXTRINSIC_VERSION","extrinsicType","derive","_decorateDeriveRx","_derive","_decorateDerive"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _classPrivateFieldLooseBase2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classPrivateFieldLooseBase\"));\n\nvar _classPrivateFieldLooseKey2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classPrivateFieldLooseKey\"));\n\nvar _rxjs = require(\"rxjs\");\n\nvar _operators = require(\"rxjs/operators\");\n\nvar _types = require(\"@polkadot/types\");\n\nvar _Extrinsic = require(\"@polkadot/types/extrinsic/Extrinsic\");\n\nvar _typesKnown = require(\"@polkadot/types-known\");\n\nvar _util = require(\"@polkadot/util\");\n\nvar _utilCrypto = require(\"@polkadot/util-crypto\");\n\nvar _Decorate = _interopRequireDefault(require(\"./Decorate\"));\n\n// Copyright 2017-2020 @polkadot/api authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nconst KEEPALIVE_INTERVAL = 15000;\nconst DEFAULT_BLOCKNUMBER = {\n  unwrap: () => _util.BN_ZERO\n};\nconst l = (0, _util.logger)('api/init');\n\nvar _healthTimer = (0, _classPrivateFieldLooseKey2.default)(\"healthTimer\");\n\nvar _registries = (0, _classPrivateFieldLooseKey2.default)(\"registries\");\n\nvar _updateSub = (0, _classPrivateFieldLooseKey2.default)(\"updateSub\");\n\nvar _onProviderConnect = (0, _classPrivateFieldLooseKey2.default)(\"onProviderConnect\");\n\nvar _onProviderDisconnect = (0, _classPrivateFieldLooseKey2.default)(\"onProviderDisconnect\");\n\nvar _onProviderError = (0, _classPrivateFieldLooseKey2.default)(\"onProviderError\");\n\nclass Init extends _Decorate.default {\n  constructor(options, type, decorateMethod) {\n    super(options, type, decorateMethod);\n    Object.defineProperty(this, _healthTimer, {\n      writable: true,\n      value: null\n    });\n    Object.defineProperty(this, _registries, {\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, _updateSub, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _onProviderConnect, {\n      writable: true,\n      value: async () => {\n        this.emit('connected');\n\n        this._isConnected.next(true);\n\n        try {\n          const [hasMeta, cryptoReady] = await Promise.all([this._loadMeta(), this._options.initWasm === false ? Promise.resolve(true) : (0, _utilCrypto.cryptoWaitReady)()]);\n\n          if (hasMeta && !this._isReady && cryptoReady) {\n            this._isReady = true;\n            this.emit('ready', this);\n          }\n\n          (0, _classPrivateFieldLooseBase2.default)(this, _healthTimer)[_healthTimer] = setInterval(() => {\n            this._rpcCore.system.health().toPromise().catch(() => {// ignore\n            });\n          }, KEEPALIVE_INTERVAL);\n        } catch (_error) {\n          const error = new Error(`FATAL: Unable to initialize the API: ${_error.message}`);\n          l.error(error);\n          this.emit('error', error);\n        }\n      }\n    });\n    Object.defineProperty(this, _onProviderDisconnect, {\n      writable: true,\n      value: () => {\n        this.emit('disconnected');\n\n        this._isConnected.next(false);\n\n        if ((0, _classPrivateFieldLooseBase2.default)(this, _healthTimer)[_healthTimer]) {\n          clearInterval((0, _classPrivateFieldLooseBase2.default)(this, _healthTimer)[_healthTimer]);\n          (0, _classPrivateFieldLooseBase2.default)(this, _healthTimer)[_healthTimer] = null;\n        }\n      }\n    });\n    Object.defineProperty(this, _onProviderError, {\n      writable: true,\n      value: error => {\n        this.emit('error', error);\n      }\n    });\n\n    if (!this.hasSubscriptions) {\n      l.warn('Api will be available in a limited mode since the provider does not support subscriptions');\n    } // all injected types added to the registry for overrides\n\n\n    this.registry.setKnownTypes(options); // We only register the types (global) if this is not a cloned instance.\n    // Do right up-front, so we get in the user types before we are actually\n    // doing anything on-chain, this ensures we have the overrides in-place\n\n    if (!options.source) {\n      this.registerTypes(options.types);\n    } else {\n      (0, _classPrivateFieldLooseBase2.default)(this, _registries)[_registries] = (0, _classPrivateFieldLooseBase2.default)(options.source, _registries)[_registries];\n    }\n\n    this._rpc = this._decorateRpc(this._rpcCore, this._decorateMethod);\n    this._rx.rpc = this._decorateRpc(this._rpcCore, this._rxDecorateMethod);\n    this._queryMulti = this._decorateMulti(this._decorateMethod);\n    this._rx.queryMulti = this._decorateMulti(this._rxDecorateMethod);\n    this._rx.signer = options.signer;\n\n    this._rpcCore.setRegistrySwap(hash => this.getBlockRegistry(hash));\n\n    this._rpcCore.provider.on('disconnected', (0, _classPrivateFieldLooseBase2.default)(this, _onProviderDisconnect)[_onProviderDisconnect]);\n\n    this._rpcCore.provider.on('error', (0, _classPrivateFieldLooseBase2.default)(this, _onProviderError)[_onProviderError]);\n\n    this._rpcCore.provider.on('connected', (0, _classPrivateFieldLooseBase2.default)(this, _onProviderConnect)[_onProviderConnect]); // If the provider was instantiated earlier, and has already emitted a\n    // 'connected' event, then the `on('connected')` won't fire anymore. To\n    // cater for this case, we call manually `this._onProviderConnect`.\n\n\n    if (this._rpcCore.provider.isConnected) {\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      (0, _classPrivateFieldLooseBase2.default)(this, _onProviderConnect)[_onProviderConnect]();\n    }\n  }\n  /**\n   * @description Decorates a registry based on the runtime version\n   */\n\n\n  _initRegistry(registry, chain, version, chainProps) {\n    registry.setChainProperties(chainProps || this.registry.getChainProperties());\n    registry.setKnownTypes(this._options);\n    registry.register((0, _typesKnown.getSpecTypes)(registry, chain, version.specName, version.specVersion)); // for bundled types, pull through the aliasses defined\n\n    if (registry.knownTypes.typesBundle) {\n      registry.knownTypes.typesAlias = (0, _typesKnown.getSpecAlias)(registry, chain, version.specName);\n    }\n\n    return registry;\n  }\n  /**\n   * @description Sets up a registry based on the block hash defined\n   */\n\n\n  async getBlockRegistry(blockHash) {\n    // shortcut in the case where we have an immediate-same request\n    const lastBlockHash = (0, _util.u8aToU8a)(blockHash);\n\n    const existingViaHash = (0, _classPrivateFieldLooseBase2.default)(this, _registries)[_registries].find(r => r.lastBlockHash && (0, _util.u8aEq)(lastBlockHash, r.lastBlockHash));\n\n    if (existingViaHash) {\n      return existingViaHash;\n    } // ensure we have everything required\n\n\n    (0, _util.assert)(this._genesisHash && this._runtimeVersion, 'Cannot retrieve data on an uninitialized chain'); // We have to assume that on the RPC layer the calls used here does not call back into\n    // the registry swap, so getHeader & getRuntimeVersion should not be historic\n\n    const header = this._genesisHash.eq(blockHash) ? {\n      number: DEFAULT_BLOCKNUMBER,\n      parentHash: this._genesisHash\n    } : await this._rpcCore.chain.getHeader(blockHash).toPromise();\n    (0, _util.assert)((header === null || header === void 0 ? void 0 : header.parentHash) && !header.parentHash.isEmpty, 'Unable to retrieve header and parent from supplied hash'); // get the runtime version, either on-chain or via an known upgrade history\n\n    const [firstVersion, lastVersion] = (0, _typesKnown.getUpgradeVersion)(this._genesisHash, header.number.unwrap());\n    const version = firstVersion && (lastVersion || firstVersion.specVersion.eq(this._runtimeVersion.specVersion)) ? {\n      specName: this._runtimeVersion.specName,\n      specVersion: firstVersion.specVersion\n    } : await this._rpcCore.state.getRuntimeVersion(header.parentHash).toPromise(); // check for pre-existing registries\n\n    const existingViaVersion = (0, _classPrivateFieldLooseBase2.default)(this, _registries)[_registries].find(r => r.specVersion.eq(version.specVersion));\n\n    if (existingViaVersion) {\n      existingViaVersion.lastBlockHash = lastBlockHash;\n      return existingViaVersion;\n    } // nothing has been found, construct new\n\n\n    const registry = this._initRegistry(new _types.TypeRegistry(), this._runtimeChain, version);\n\n    const metadata = await this._rpcCore.state.getMetadata(header.parentHash).toPromise();\n    const result = {\n      isDefault: false,\n      lastBlockHash,\n      metadata,\n      metadataConsts: null,\n      registry,\n      specVersion: version.specVersion\n    };\n    registry.setMetadata(metadata);\n\n    (0, _classPrivateFieldLooseBase2.default)(this, _registries)[_registries].push(result);\n\n    return result;\n  }\n\n  async _loadMeta() {\n    var _this$_options$source;\n\n    const genesisHash = await this._rpcCore.chain.getBlockHash(0).toPromise(); // on re-connection to the same chain, we don't want to re-do everything from chain again\n\n    if (this._isReady && !this._options.source && genesisHash.eq(this._genesisHash)) {\n      return true;\n    }\n\n    if (this._genesisHash) {\n      l.warn('Connection to new genesis detected, re-initializing');\n    }\n\n    this._genesisHash = genesisHash;\n\n    if ((0, _classPrivateFieldLooseBase2.default)(this, _updateSub)[_updateSub]) {\n      (0, _classPrivateFieldLooseBase2.default)(this, _updateSub)[_updateSub].unsubscribe();\n    }\n\n    const {\n      metadata = {}\n    } = this._options; // only load from on-chain if we are not a clone (default path), alternatively\n    // just use the values from the source instance provided\n\n    this._runtimeMetadata = ((_this$_options$source = this._options.source) === null || _this$_options$source === void 0 ? void 0 : _this$_options$source._isReady) ? await this._metaFromSource(this._options.source) : await this._metaFromChain(metadata);\n    return this._initFromMeta(this._runtimeMetadata);\n  } // eslint-disable-next-line @typescript-eslint/require-await\n\n\n  async _metaFromSource(source) {\n    this._extrinsicType = source.extrinsicVersion;\n    this._runtimeChain = source.runtimeChain;\n    this._runtimeVersion = source.runtimeVersion;\n    this._genesisHash = source.genesisHash;\n    const methods = []; // manually build a list of all available methods in this RPC, we are\n    // going to filter on it to align the cloned RPC without making a call\n\n    Object.keys(source.rpc).forEach(section => {\n      Object.keys(source.rpc[section]).forEach(method => {\n        methods.push(`${section}_${method}`);\n      });\n    });\n\n    this._filterRpcMethods(methods);\n\n    return source.runtimeMetadata;\n  } // subscribe to metadata updates, inject the types on changes\n\n\n  _subscribeUpdates() {\n    if ((0, _classPrivateFieldLooseBase2.default)(this, _updateSub)[_updateSub] || !this.hasSubscriptions) {\n      return;\n    }\n\n    (0, _classPrivateFieldLooseBase2.default)(this, _updateSub)[_updateSub] = this._rpcCore.state.subscribeRuntimeVersion().pipe((0, _operators.switchMap)(version => {\n      var _this$_runtimeVersion;\n\n      return (// only retrieve the metadata when the on-chain version has been changed\n        ((_this$_runtimeVersion = this._runtimeVersion) === null || _this$_runtimeVersion === void 0 ? void 0 : _this$_runtimeVersion.specVersion.eq(version.specVersion)) ? (0, _rxjs.of)(false) : this._rpcCore.state.getMetadata().pipe((0, _operators.map)(metadata => {\n          l.log(`Runtime version updated to spec=${version.specVersion.toString()}, tx=${version.transactionVersion.toString()}`);\n          this._runtimeMetadata = metadata;\n          this._runtimeVersion = version;\n          this._rx.runtimeVersion = version; // update the default registry version\n\n          const thisRegistry = (0, _classPrivateFieldLooseBase2.default)(this, _registries)[_registries].find(({\n            isDefault\n          }) => isDefault);\n\n          (0, _util.assert)(thisRegistry, 'Initialization error, cannot find the default registry'); // setup the data as per the current versions\n\n          thisRegistry.metadata = metadata;\n          thisRegistry.metadataConsts = null;\n          thisRegistry.registry.setMetadata(metadata);\n          thisRegistry.specVersion = version.specVersion; // clear the registry types to ensure that we override correctly\n\n          this._initRegistry(thisRegistry.registry.init(), this._runtimeChain, version);\n\n          this.injectMetadata(metadata, false, thisRegistry.registry);\n          return true;\n        }))\n      );\n    })).subscribe();\n  }\n\n  async _metaFromChain(optMetadata) {\n    var _this$_genesisHash;\n\n    const [runtimeVersion, chain, chainProps] = await Promise.all([this._rpcCore.state.getRuntimeVersion().toPromise(), this._rpcCore.system.chain().toPromise(), this._rpcCore.system.properties().toPromise()]); // set our chain version & genesisHash as returned\n\n    this._runtimeChain = chain;\n    this._runtimeVersion = runtimeVersion;\n    this._rx.runtimeVersion = runtimeVersion; // initializes the registry\n\n    this._initRegistry(this.registry, chain, runtimeVersion, chainProps);\n\n    this._subscribeUpdates(); // filter the RPC methods (this does an rpc-methods call)\n\n\n    await this._filterRpc(); // retrieve metadata, either from chain  or as pass-in via options\n\n    const metadataKey = `${((_this$_genesisHash = this._genesisHash) === null || _this$_genesisHash === void 0 ? void 0 : _this$_genesisHash.toHex()) || '0x'}-${runtimeVersion.specVersion.toString()}`;\n    const metadata = metadataKey in optMetadata ? new _types.Metadata(this.registry, optMetadata[metadataKey]) : await this._rpcCore.state.getMetadata().toPromise();\n    this.registry.setMetadata(metadata); // setup the initial registry, when we have none\n\n    if (!(0, _classPrivateFieldLooseBase2.default)(this, _registries)[_registries].length) {\n      (0, _classPrivateFieldLooseBase2.default)(this, _registries)[_registries].push({\n        isDefault: true,\n        lastBlockHash: null,\n        metadata,\n        metadataConsts: null,\n        registry: this.registry,\n        specVersion: runtimeVersion.specVersion\n      });\n    } // get unique types & validate\n\n\n    metadata.getUniqTypes(false);\n    return metadata;\n  }\n\n  async _initFromMeta(metadata) {\n    const metaExtrinsic = metadata.asLatest.extrinsic; // only inject if we are not a clone (global init)\n\n    if (metaExtrinsic.version.gt(_util.BN_ZERO)) {\n      this._extrinsicType = metaExtrinsic.version.toNumber();\n    } else if (!this._options.source) {\n      // detect the extrinsic version in-use based on the last block\n      const {\n        block: {\n          extrinsics: [firstTx]\n        }\n      } = await this._rpcCore.chain.getBlock().toPromise(); // If we haven't sync-ed to 1 yes, this won't have any values\n\n      this._extrinsicType = firstTx ? firstTx.type : _Extrinsic.LATEST_EXTRINSIC_VERSION;\n    }\n\n    this._rx.extrinsicType = this._extrinsicType;\n    this._rx.genesisHash = this._genesisHash;\n    this._rx.runtimeVersion = this._runtimeVersion;\n    this.injectMetadata(metadata, true); // derive is last, since it uses the decorated rx\n\n    this._rx.derive = this._decorateDeriveRx(this._rxDecorateMethod);\n    this._derive = this._decorateDerive(this._decorateMethod);\n    return true;\n  }\n\n}\n\nexports.default = Init;"]},"metadata":{},"sourceType":"script"}