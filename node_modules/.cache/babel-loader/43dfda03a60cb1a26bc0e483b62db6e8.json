{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.CallIndex = void 0;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _util = require(\"@polkadot/util\");\n\nvar _create = require(\"../create\");\n\nvar _Struct = _interopRequireDefault(require(\"../codec/Struct\"));\n\nvar _U8aFixed = _interopRequireDefault(require(\"../codec/U8aFixed\"));\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2.default)(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n/**\n * Get a mapping of `argument name -> argument type` for the function, from\n * its metadata.\n *\n * @param meta - The function metadata used to get the definition.\n * @internal\n */\n\n\nfunction getArgsDef(registry, meta) {\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  return Call.filterOrigin(meta).reduce((result, {\n    name,\n    type\n  }) => {\n    const Type = (0, _create.getTypeClass)(registry, (0, _create.getTypeDef)(type.toString()));\n    result[name.toString()] = Type;\n    return result;\n  }, {});\n}\n/** @internal */\n\n\nfunction decodeCallViaObject(registry, value, _meta) {\n  // we only pass args/methodsIndex out\n  const {\n    args,\n    callIndex\n  } = value; // Get the correct lookupIndex\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n\n  const lookupIndex = callIndex instanceof CallIndex ? callIndex.toU8a() : callIndex; // Find metadata with callIndex\n\n  const meta = _meta || registry.findMetaCall(lookupIndex).meta;\n\n  return {\n    args,\n    argsDef: getArgsDef(registry, meta),\n    callIndex,\n    meta\n  };\n}\n/** @internal */\n\n\nfunction decodeCallViaU8a(registry, value, _meta) {\n  // We need 2 bytes for the callIndex\n  const callIndex = new Uint8Array(2);\n  callIndex.set(value.subarray(0, 2), 0); // Find metadata with callIndex\n\n  const meta = _meta || registry.findMetaCall(callIndex).meta;\n\n  return {\n    args: value.subarray(2),\n    argsDef: getArgsDef(registry, meta),\n    callIndex,\n    meta\n  };\n}\n/**\n * Decode input to pass into constructor.\n *\n * @param value - Value to decode, one of:\n * - hex\n * - Uint8Array\n * - {@see DecodeMethodInput}\n * @param _meta - Metadata to use, so that `injectMethods` lookup is not\n * necessary.\n * @internal\n */\n\n\nfunction decodeCall(registry, value = new Uint8Array(), _meta) {\n  if ((0, _util.isHex)(value) || (0, _util.isU8a)(value)) {\n    return decodeCallViaU8a(registry, (0, _util.u8aToU8a)(value), _meta);\n  } else if ((0, _util.isObject)(value) && value.callIndex && value.args) {\n    return decodeCallViaObject(registry, value, _meta);\n  }\n\n  throw new Error(`Call: Cannot decode value '${value}' of type ${typeof value}`);\n}\n/**\n * @name CallIndex\n * @description\n * A wrapper around the `[sectionIndex, methodIndex]` value that uniquely identifies a method\n */\n\n\nclass CallIndex extends _U8aFixed.default {\n  constructor(registry, value) {\n    super(registry, value, 16);\n  }\n\n}\n/**\n * @name Call\n * @description\n * Extrinsic function descriptor, as defined in\n * {@link https://github.com/paritytech/wiki/blob/master/Extrinsic.md#the-extrinsic-format-for-node}.\n */\n\n\nexports.CallIndex = CallIndex;\n\nclass Call extends _Struct.default {\n  constructor(registry, value, meta) {\n    const decoded = decodeCall(registry, value, meta);\n    super(registry, {\n      callIndex: CallIndex,\n      // eslint-disable-next-line sort-keys\n      args: _Struct.default.with(decoded.argsDef)\n    }, decoded);\n    this._meta = void 0;\n    this._meta = decoded.meta;\n  } // If the extrinsic function has an argument of type `Origin`, we ignore it\n\n\n  static filterOrigin(meta) {\n    // FIXME should be `arg.type !== Origin`, but doesn't work...\n    return meta ? meta.args.filter(({\n      type\n    }) => type.toString() !== 'Origin') : [];\n  }\n  /**\n   * @description The arguments for the function call\n   */\n\n\n  get args() {\n    // FIXME This should return a Struct instead of an Array\n    return [...this.get('args').values()];\n  }\n  /**\n   * @description The argument definitions\n   */\n\n\n  get argsDef() {\n    return getArgsDef(this.registry, this.meta);\n  }\n  /**\n   * @description The encoded `[sectionIndex, methodIndex]` identifier\n   */\n\n\n  get callIndex() {\n    return this.get('callIndex').toU8a();\n  }\n  /**\n   * @description The encoded data\n   */\n\n\n  get data() {\n    return this.get('args').toU8a();\n  }\n  /**\n   * @description `true` if the `Origin` type is on the method (extrinsic method)\n   */\n\n\n  get hasOrigin() {\n    const firstArg = this.meta.args[0];\n    return !!firstArg && firstArg.type.toString() === 'Origin';\n  }\n  /**\n   * @description The [[FunctionMetadata]]\n   */\n\n\n  get meta() {\n    return this._meta;\n  }\n  /**\n   * @description Returns the name of the method\n   */\n\n\n  get methodName() {\n    return this.registry.findMetaCall(this.callIndex).method;\n  }\n  /**\n   * @description Returns the name of the method\n   */\n\n\n  get method() {\n    return this.methodName;\n  }\n  /**\n   * @description Returns the module containing the method\n   */\n\n\n  get sectionName() {\n    return this.registry.findMetaCall(this.callIndex).section;\n  }\n  /**\n   * @description Returns the module containing the method\n   */\n\n\n  get section() {\n    return this.sectionName;\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n\n\n  toHuman(isExpanded) {\n    var _call, _call2;\n\n    let call;\n\n    try {\n      call = this.registry.findMetaCall(this.callIndex);\n    } catch (error) {// swallow\n    }\n\n    return _objectSpread({\n      args: this.args.map(arg => arg.toHuman(isExpanded)),\n      // args: this.args.map((arg, index) => call\n      //   ? { [call.meta.args[index].name.toString()]: arg.toHuman(isExpanded) }\n      //   : arg.toHuman(isExpanded)\n      // ),\n      // callIndex: u8aToHex(this.callIndex),\n      method: (_call = call) === null || _call === void 0 ? void 0 : _call.method,\n      section: (_call2 = call) === null || _call2 === void 0 ? void 0 : _call2.section\n    }, isExpanded && call ? {\n      documentation: call.meta.documentation.map(d => d.toString())\n    } : {});\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType() {\n    return 'Call';\n  }\n\n}\n\nexports.default = Call;","map":{"version":3,"sources":["/home/robin/substrate-front-end-template/node_modules/@polkadot/types/generic/Call.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","default","CallIndex","_defineProperty2","_util","_create","_Struct","_U8aFixed","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","getArgsDef","registry","meta","Call","filterOrigin","reduce","result","name","type","Type","getTypeClass","getTypeDef","toString","decodeCallViaObject","_meta","args","callIndex","lookupIndex","toU8a","findMetaCall","argsDef","decodeCallViaU8a","Uint8Array","set","subarray","decodeCall","isHex","isU8a","u8aToU8a","isObject","Error","constructor","decoded","with","get","values","data","hasOrigin","firstArg","methodName","method","sectionName","section","toHuman","isExpanded","_call","_call2","call","error","map","arg","documentation","d","toRawType"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.CallIndex = void 0;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _util = require(\"@polkadot/util\");\n\nvar _create = require(\"../create\");\n\nvar _Struct = _interopRequireDefault(require(\"../codec/Struct\"));\n\nvar _U8aFixed = _interopRequireDefault(require(\"../codec/U8aFixed\"));\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n/**\n * Get a mapping of `argument name -> argument type` for the function, from\n * its metadata.\n *\n * @param meta - The function metadata used to get the definition.\n * @internal\n */\nfunction getArgsDef(registry, meta) {\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  return Call.filterOrigin(meta).reduce((result, {\n    name,\n    type\n  }) => {\n    const Type = (0, _create.getTypeClass)(registry, (0, _create.getTypeDef)(type.toString()));\n    result[name.toString()] = Type;\n    return result;\n  }, {});\n}\n/** @internal */\n\n\nfunction decodeCallViaObject(registry, value, _meta) {\n  // we only pass args/methodsIndex out\n  const {\n    args,\n    callIndex\n  } = value; // Get the correct lookupIndex\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n\n  const lookupIndex = callIndex instanceof CallIndex ? callIndex.toU8a() : callIndex; // Find metadata with callIndex\n\n  const meta = _meta || registry.findMetaCall(lookupIndex).meta;\n\n  return {\n    args,\n    argsDef: getArgsDef(registry, meta),\n    callIndex,\n    meta\n  };\n}\n/** @internal */\n\n\nfunction decodeCallViaU8a(registry, value, _meta) {\n  // We need 2 bytes for the callIndex\n  const callIndex = new Uint8Array(2);\n  callIndex.set(value.subarray(0, 2), 0); // Find metadata with callIndex\n\n  const meta = _meta || registry.findMetaCall(callIndex).meta;\n\n  return {\n    args: value.subarray(2),\n    argsDef: getArgsDef(registry, meta),\n    callIndex,\n    meta\n  };\n}\n/**\n * Decode input to pass into constructor.\n *\n * @param value - Value to decode, one of:\n * - hex\n * - Uint8Array\n * - {@see DecodeMethodInput}\n * @param _meta - Metadata to use, so that `injectMethods` lookup is not\n * necessary.\n * @internal\n */\n\n\nfunction decodeCall(registry, value = new Uint8Array(), _meta) {\n  if ((0, _util.isHex)(value) || (0, _util.isU8a)(value)) {\n    return decodeCallViaU8a(registry, (0, _util.u8aToU8a)(value), _meta);\n  } else if ((0, _util.isObject)(value) && value.callIndex && value.args) {\n    return decodeCallViaObject(registry, value, _meta);\n  }\n\n  throw new Error(`Call: Cannot decode value '${value}' of type ${typeof value}`);\n}\n/**\n * @name CallIndex\n * @description\n * A wrapper around the `[sectionIndex, methodIndex]` value that uniquely identifies a method\n */\n\n\nclass CallIndex extends _U8aFixed.default {\n  constructor(registry, value) {\n    super(registry, value, 16);\n  }\n\n}\n/**\n * @name Call\n * @description\n * Extrinsic function descriptor, as defined in\n * {@link https://github.com/paritytech/wiki/blob/master/Extrinsic.md#the-extrinsic-format-for-node}.\n */\n\n\nexports.CallIndex = CallIndex;\n\nclass Call extends _Struct.default {\n  constructor(registry, value, meta) {\n    const decoded = decodeCall(registry, value, meta);\n    super(registry, {\n      callIndex: CallIndex,\n      // eslint-disable-next-line sort-keys\n      args: _Struct.default.with(decoded.argsDef)\n    }, decoded);\n    this._meta = void 0;\n    this._meta = decoded.meta;\n  } // If the extrinsic function has an argument of type `Origin`, we ignore it\n\n\n  static filterOrigin(meta) {\n    // FIXME should be `arg.type !== Origin`, but doesn't work...\n    return meta ? meta.args.filter(({\n      type\n    }) => type.toString() !== 'Origin') : [];\n  }\n  /**\n   * @description The arguments for the function call\n   */\n\n\n  get args() {\n    // FIXME This should return a Struct instead of an Array\n    return [...this.get('args').values()];\n  }\n  /**\n   * @description The argument definitions\n   */\n\n\n  get argsDef() {\n    return getArgsDef(this.registry, this.meta);\n  }\n  /**\n   * @description The encoded `[sectionIndex, methodIndex]` identifier\n   */\n\n\n  get callIndex() {\n    return this.get('callIndex').toU8a();\n  }\n  /**\n   * @description The encoded data\n   */\n\n\n  get data() {\n    return this.get('args').toU8a();\n  }\n  /**\n   * @description `true` if the `Origin` type is on the method (extrinsic method)\n   */\n\n\n  get hasOrigin() {\n    const firstArg = this.meta.args[0];\n    return !!firstArg && firstArg.type.toString() === 'Origin';\n  }\n  /**\n   * @description The [[FunctionMetadata]]\n   */\n\n\n  get meta() {\n    return this._meta;\n  }\n  /**\n   * @description Returns the name of the method\n   */\n\n\n  get methodName() {\n    return this.registry.findMetaCall(this.callIndex).method;\n  }\n  /**\n   * @description Returns the name of the method\n   */\n\n\n  get method() {\n    return this.methodName;\n  }\n  /**\n   * @description Returns the module containing the method\n   */\n\n\n  get sectionName() {\n    return this.registry.findMetaCall(this.callIndex).section;\n  }\n  /**\n   * @description Returns the module containing the method\n   */\n\n\n  get section() {\n    return this.sectionName;\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n\n\n  toHuman(isExpanded) {\n    var _call, _call2;\n\n    let call;\n\n    try {\n      call = this.registry.findMetaCall(this.callIndex);\n    } catch (error) {// swallow\n    }\n\n    return _objectSpread({\n      args: this.args.map(arg => arg.toHuman(isExpanded)),\n      // args: this.args.map((arg, index) => call\n      //   ? { [call.meta.args[index].name.toString()]: arg.toHuman(isExpanded) }\n      //   : arg.toHuman(isExpanded)\n      // ),\n      // callIndex: u8aToHex(this.callIndex),\n      method: (_call = call) === null || _call === void 0 ? void 0 : _call.method,\n      section: (_call2 = call) === null || _call2 === void 0 ? void 0 : _call2.section\n    }, isExpanded && call ? {\n      documentation: call.meta.documentation.map(d => d.toString())\n    } : {});\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType() {\n    return 'Call';\n  }\n\n}\n\nexports.default = Call;"]},"metadata":{},"sourceType":"script"}