{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.web3Enable = web3Enable;\nexports.web3Accounts = web3Accounts;\nexports.web3AccountsSubscribe = web3AccountsSubscribe;\nexports.web3FromSource = web3FromSource;\nexports.web3FromAddress = web3FromAddress;\nexports.web3ListRpcProviders = web3ListRpcProviders;\nexports.web3UseRpcProvider = web3UseRpcProvider;\nexports.web3EnablePromise = exports.isWeb3Injected = void 0;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _utilCrypto = require(\"@polkadot/util-crypto\");\n\nvar _util = require(\"./util\");\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2.default)(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // just a helper (otherwise we cast all-over, so shorter and more readable)\n\n\nconst win = window; // don't clobber the existing object, but ensure non-undefined\n\nwin.injectedWeb3 = win.injectedWeb3 || {}; // true when anything has been injected and is available\n\nfunction web3IsInjected() {\n  return Object.keys(win.injectedWeb3).length !== 0;\n} // helper to throw a consistent error when not enabled\n\n\nfunction throwError(method) {\n  throw new Error(`${method}: web3Enable(originName) needs to be called before ${method}`);\n} // internal helper to map from Array<InjectedAccount> -> Array<InjectedAccountWithMeta>\n\n\nfunction mapAccounts(source, list, ss58Format) {\n  return list.map(({\n    address,\n    genesisHash,\n    name\n  }) => {\n    const encodedAddress = (0, _utilCrypto.encodeAddress)((0, _utilCrypto.decodeAddress)(address), ss58Format);\n    return {\n      address: encodedAddress,\n      meta: {\n        genesisHash,\n        name,\n        source\n      }\n    };\n  });\n} // have we found a properly constructed window.injectedWeb3\n\n\nlet isWeb3Injected = web3IsInjected(); // we keep the last promise created around (for queries)\n\nexports.isWeb3Injected = isWeb3Injected;\nlet web3EnablePromise = null;\nexports.web3EnablePromise = web3EnablePromise; // enables all the providers found on the injected window interface\n\nfunction web3Enable(originName) {\n  if (!originName) {\n    throw new Error('You must pass a name for your app to the web3Enable function');\n  }\n\n  exports.web3EnablePromise = web3EnablePromise = (0, _util.documentReadyPromise)(() => Promise.all(Object.entries(win.injectedWeb3).map(([name, {\n    enable,\n    version\n  }]) => {\n    return Promise.all([Promise.resolve({\n      name,\n      version\n    }), enable(originName).catch(error => {\n      console.error(`Error initializing ${name}: ${error.message}`);\n    })]);\n  })).then(values => values.filter(([, ext]) => !!ext).map(([info, ext]) => {\n    // if we don't have an accounts subscriber, add a single-shot version\n    if (ext && !ext.accounts.subscribe) {\n      ext.accounts.subscribe = cb => {\n        ext.accounts.get().then(cb).catch(console.error);\n        return () => {// no ubsubscribe needed, this is a single-shot\n        };\n      };\n    }\n\n    const injected = _objectSpread(_objectSpread({}, info), ext);\n\n    return injected;\n  })).catch(() => []).then(values => {\n    const names = values.map(({\n      name,\n      version\n    }) => `${name}/${version}`);\n    exports.isWeb3Injected = isWeb3Injected = web3IsInjected();\n    console.log(`web3Enable: Enabled ${values.length} extension${values.length !== 1 ? 's' : ''}: ${names.join(', ')}`);\n    return values;\n  }));\n  return web3EnablePromise;\n} // retrieve all the accounts accross all providers\n\n\nasync function web3Accounts({\n  ss58Format\n} = {}) {\n  if (!web3EnablePromise) {\n    return throwError('web3Accounts');\n  }\n\n  const accounts = [];\n  const injected = await web3EnablePromise;\n  const retrieved = await Promise.all(injected.map(async ({\n    accounts,\n    name: source\n  }) => {\n    try {\n      const list = await accounts.get();\n      return mapAccounts(source, list, ss58Format);\n    } catch (error) {\n      // cannot handle this one\n      return [];\n    }\n  }));\n  retrieved.forEach(result => {\n    accounts.push(...result);\n  });\n  const addresses = accounts.map(({\n    address\n  }) => address);\n  console.log(`web3Accounts: Found ${accounts.length} address${accounts.length !== 1 ? 'es' : ''}: ${addresses.join(', ')}`);\n  return accounts;\n}\n\nasync function web3AccountsSubscribe(cb, {\n  ss58Format\n} = {}) {\n  if (!web3EnablePromise) {\n    return throwError('web3AccountsSubscribe');\n  }\n\n  const accounts = {};\n\n  const triggerUpdate = () => cb(Object.entries(accounts).reduce((result, [source, list]) => {\n    result.push(...mapAccounts(source, list, ss58Format));\n    return result;\n  }, []));\n\n  const unsubs = (await web3EnablePromise).map(({\n    accounts: {\n      subscribe\n    },\n    name: source\n  }) => subscribe(result => {\n    accounts[source] = result; // eslint-disable-next-line @typescript-eslint/no-floating-promises\n\n    triggerUpdate();\n  }));\n  return () => {\n    unsubs.forEach(unsub => {\n      unsub();\n    });\n  };\n} // find a specific provider based on the name\n\n\nasync function web3FromSource(source) {\n  if (!web3EnablePromise) {\n    return throwError('web3FromSource');\n  }\n\n  const sources = await web3EnablePromise;\n  const found = source && sources.find(({\n    name\n  }) => name === source);\n\n  if (!found) {\n    throw new Error(`web3FromSource: Unable to find an injected ${source}`);\n  }\n\n  return found;\n} // find a specific provider based on an address\n\n\nasync function web3FromAddress(address) {\n  if (!web3EnablePromise) {\n    return throwError('web3FromAddress');\n  }\n\n  const accounts = await web3Accounts();\n  const found = address && accounts.find(account => account.address === address);\n\n  if (!found) {\n    throw new Error(`web3FromAddress: Unable to find injected ${address}`);\n  }\n\n  return web3FromSource(found.meta.source);\n} // retrieve all providers exposed by one source\n\n\nasync function web3ListRpcProviders(source) {\n  const {\n    provider\n  } = await web3FromSource(source);\n\n  if (!provider) {\n    console.warn(`Extension ${source} does not expose any provider`);\n    return null;\n  }\n\n  return provider.listProviders();\n} // retrieve all providers exposed by one source\n\n\nasync function web3UseRpcProvider(source, key) {\n  const {\n    provider\n  } = await web3FromSource(source);\n\n  if (!provider) {\n    throw new Error(`Extension ${source} does not expose any provider`);\n  }\n\n  const meta = await provider.startProvider(key);\n  return {\n    meta,\n    provider\n  };\n}","map":{"version":3,"sources":["/home/robin/substrate-front-end-template/node_modules/@polkadot/extension-dapp/index.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","web3Enable","web3Accounts","web3AccountsSubscribe","web3FromSource","web3FromAddress","web3ListRpcProviders","web3UseRpcProvider","web3EnablePromise","isWeb3Injected","_defineProperty2","_utilCrypto","_util","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","default","getOwnPropertyDescriptors","defineProperties","win","window","injectedWeb3","web3IsInjected","throwError","method","Error","mapAccounts","list","ss58Format","map","address","genesisHash","name","encodedAddress","encodeAddress","decodeAddress","meta","originName","documentReadyPromise","Promise","all","entries","enable","version","resolve","catch","error","console","message","then","values","ext","info","accounts","subscribe","cb","get","injected","names","log","join","retrieved","result","addresses","triggerUpdate","reduce","unsubs","unsub","sources","found","find","account","provider","warn","listProviders","startProvider"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.web3Enable = web3Enable;\nexports.web3Accounts = web3Accounts;\nexports.web3AccountsSubscribe = web3AccountsSubscribe;\nexports.web3FromSource = web3FromSource;\nexports.web3FromAddress = web3FromAddress;\nexports.web3ListRpcProviders = web3ListRpcProviders;\nexports.web3UseRpcProvider = web3UseRpcProvider;\nexports.web3EnablePromise = exports.isWeb3Injected = void 0;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _utilCrypto = require(\"@polkadot/util-crypto\");\n\nvar _util = require(\"./util\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n// just a helper (otherwise we cast all-over, so shorter and more readable)\nconst win = window; // don't clobber the existing object, but ensure non-undefined\n\nwin.injectedWeb3 = win.injectedWeb3 || {}; // true when anything has been injected and is available\n\nfunction web3IsInjected() {\n  return Object.keys(win.injectedWeb3).length !== 0;\n} // helper to throw a consistent error when not enabled\n\n\nfunction throwError(method) {\n  throw new Error(`${method}: web3Enable(originName) needs to be called before ${method}`);\n} // internal helper to map from Array<InjectedAccount> -> Array<InjectedAccountWithMeta>\n\n\nfunction mapAccounts(source, list, ss58Format) {\n  return list.map(({\n    address,\n    genesisHash,\n    name\n  }) => {\n    const encodedAddress = (0, _utilCrypto.encodeAddress)((0, _utilCrypto.decodeAddress)(address), ss58Format);\n    return {\n      address: encodedAddress,\n      meta: {\n        genesisHash,\n        name,\n        source\n      }\n    };\n  });\n} // have we found a properly constructed window.injectedWeb3\n\n\nlet isWeb3Injected = web3IsInjected(); // we keep the last promise created around (for queries)\n\nexports.isWeb3Injected = isWeb3Injected;\nlet web3EnablePromise = null;\nexports.web3EnablePromise = web3EnablePromise;\n\n// enables all the providers found on the injected window interface\nfunction web3Enable(originName) {\n  if (!originName) {\n    throw new Error('You must pass a name for your app to the web3Enable function');\n  }\n\n  exports.web3EnablePromise = web3EnablePromise = (0, _util.documentReadyPromise)(() => Promise.all(Object.entries(win.injectedWeb3).map(([name, {\n    enable,\n    version\n  }]) => {\n    return Promise.all([Promise.resolve({\n      name,\n      version\n    }), enable(originName).catch(error => {\n      console.error(`Error initializing ${name}: ${error.message}`);\n    })]);\n  })).then(values => values.filter(([, ext]) => !!ext).map(([info, ext]) => {\n    // if we don't have an accounts subscriber, add a single-shot version\n    if (ext && !ext.accounts.subscribe) {\n      ext.accounts.subscribe = cb => {\n        ext.accounts.get().then(cb).catch(console.error);\n        return () => {// no ubsubscribe needed, this is a single-shot\n        };\n      };\n    }\n\n    const injected = _objectSpread(_objectSpread({}, info), ext);\n\n    return injected;\n  })).catch(() => []).then(values => {\n    const names = values.map(({\n      name,\n      version\n    }) => `${name}/${version}`);\n    exports.isWeb3Injected = isWeb3Injected = web3IsInjected();\n    console.log(`web3Enable: Enabled ${values.length} extension${values.length !== 1 ? 's' : ''}: ${names.join(', ')}`);\n    return values;\n  }));\n  return web3EnablePromise;\n} // retrieve all the accounts accross all providers\n\n\nasync function web3Accounts({\n  ss58Format\n} = {}) {\n  if (!web3EnablePromise) {\n    return throwError('web3Accounts');\n  }\n\n  const accounts = [];\n  const injected = await web3EnablePromise;\n  const retrieved = await Promise.all(injected.map(async ({\n    accounts,\n    name: source\n  }) => {\n    try {\n      const list = await accounts.get();\n      return mapAccounts(source, list, ss58Format);\n    } catch (error) {\n      // cannot handle this one\n      return [];\n    }\n  }));\n  retrieved.forEach(result => {\n    accounts.push(...result);\n  });\n  const addresses = accounts.map(({\n    address\n  }) => address);\n  console.log(`web3Accounts: Found ${accounts.length} address${accounts.length !== 1 ? 'es' : ''}: ${addresses.join(', ')}`);\n  return accounts;\n}\n\nasync function web3AccountsSubscribe(cb, {\n  ss58Format\n} = {}) {\n  if (!web3EnablePromise) {\n    return throwError('web3AccountsSubscribe');\n  }\n\n  const accounts = {};\n\n  const triggerUpdate = () => cb(Object.entries(accounts).reduce((result, [source, list]) => {\n    result.push(...mapAccounts(source, list, ss58Format));\n    return result;\n  }, []));\n\n  const unsubs = (await web3EnablePromise).map(({\n    accounts: {\n      subscribe\n    },\n    name: source\n  }) => subscribe(result => {\n    accounts[source] = result; // eslint-disable-next-line @typescript-eslint/no-floating-promises\n\n    triggerUpdate();\n  }));\n  return () => {\n    unsubs.forEach(unsub => {\n      unsub();\n    });\n  };\n} // find a specific provider based on the name\n\n\nasync function web3FromSource(source) {\n  if (!web3EnablePromise) {\n    return throwError('web3FromSource');\n  }\n\n  const sources = await web3EnablePromise;\n  const found = source && sources.find(({\n    name\n  }) => name === source);\n\n  if (!found) {\n    throw new Error(`web3FromSource: Unable to find an injected ${source}`);\n  }\n\n  return found;\n} // find a specific provider based on an address\n\n\nasync function web3FromAddress(address) {\n  if (!web3EnablePromise) {\n    return throwError('web3FromAddress');\n  }\n\n  const accounts = await web3Accounts();\n  const found = address && accounts.find(account => account.address === address);\n\n  if (!found) {\n    throw new Error(`web3FromAddress: Unable to find injected ${address}`);\n  }\n\n  return web3FromSource(found.meta.source);\n} // retrieve all providers exposed by one source\n\n\nasync function web3ListRpcProviders(source) {\n  const {\n    provider\n  } = await web3FromSource(source);\n\n  if (!provider) {\n    console.warn(`Extension ${source} does not expose any provider`);\n    return null;\n  }\n\n  return provider.listProviders();\n} // retrieve all providers exposed by one source\n\n\nasync function web3UseRpcProvider(source, key) {\n  const {\n    provider\n  } = await web3FromSource(source);\n\n  if (!provider) {\n    throw new Error(`Extension ${source} does not expose any provider`);\n  }\n\n  const meta = await provider.startProvider(key);\n  return {\n    meta,\n    provider\n  };\n}"]},"metadata":{},"sourceType":"script"}