{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setDeriveCache = setDeriveCache;\nexports.deriveCache = void 0;\n\nvar _cacheImpl = require(\"./cacheImpl\"); // Copyright 2017-2020 @polkadot/api-derive authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nconst CHACHE_EXPIRY = 7 * (24 * 60) * (60 * 1000);\nlet deriveCache;\nexports.deriveCache = deriveCache;\n\nfunction wrapCache(keyStart, cache) {\n  return {\n    del: partial => cache.del(`${keyStart}${partial}`),\n    forEach: cache.forEach,\n    get: partial => {\n      const key = `${keyStart}${partial}`;\n      const cached = cache.get(key);\n\n      if (cached) {\n        cached.x = Date.now();\n        cache.set(key, cached);\n        return cached.v;\n      }\n\n      return undefined;\n    },\n    set: (partial, v) => {\n      cache.set(`${keyStart}${partial}`, {\n        v,\n        x: Date.now()\n      });\n    }\n  };\n}\n\nfunction clearCache(cache) {\n  // clear all expired values\n  const now = Date.now();\n  const all = [];\n  cache.forEach((key, {\n    x\n  }) => {\n    now - x > CHACHE_EXPIRY && all.push(key);\n  }); // don't do delete inside loop, just in-case\n\n  all.forEach(key => cache.del(key));\n}\n\nfunction setDeriveCache(prefix = '', cache) {\n  exports.deriveCache = deriveCache = cache ? wrapCache(`derive:${prefix}:`, cache) : _cacheImpl.deriveNoopCache;\n\n  if (cache) {\n    clearCache(cache);\n  }\n}\n\nsetDeriveCache();","map":{"version":3,"sources":["/home/robin/substrate-front-end-template/node_modules/@polkadot/api-derive/util/cache.js"],"names":["Object","defineProperty","exports","value","setDeriveCache","deriveCache","_cacheImpl","require","CHACHE_EXPIRY","wrapCache","keyStart","cache","del","partial","forEach","get","key","cached","x","Date","now","set","v","undefined","clearCache","all","push","prefix","deriveNoopCache"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,cAAR,GAAyBA,cAAzB;AACAF,OAAO,CAACG,WAAR,GAAsB,KAAK,CAA3B;;AAEA,IAAIC,UAAU,GAAGC,OAAO,CAAC,aAAD,CAAxB,C,CAEA;AACA;;;AACA,MAAMC,aAAa,GAAG,KAAK,KAAK,EAAV,KAAiB,KAAK,IAAtB,CAAtB;AACA,IAAIH,WAAJ;AACAH,OAAO,CAACG,WAAR,GAAsBA,WAAtB;;AAEA,SAASI,SAAT,CAAmBC,QAAnB,EAA6BC,KAA7B,EAAoC;AAClC,SAAO;AACLC,IAAAA,GAAG,EAAEC,OAAO,IAAIF,KAAK,CAACC,GAAN,CAAW,GAAEF,QAAS,GAAEG,OAAQ,EAAhC,CADX;AAELC,IAAAA,OAAO,EAAEH,KAAK,CAACG,OAFV;AAGLC,IAAAA,GAAG,EAAEF,OAAO,IAAI;AACd,YAAMG,GAAG,GAAI,GAAEN,QAAS,GAAEG,OAAQ,EAAlC;AACA,YAAMI,MAAM,GAAGN,KAAK,CAACI,GAAN,CAAUC,GAAV,CAAf;;AAEA,UAAIC,MAAJ,EAAY;AACVA,QAAAA,MAAM,CAACC,CAAP,GAAWC,IAAI,CAACC,GAAL,EAAX;AACAT,QAAAA,KAAK,CAACU,GAAN,CAAUL,GAAV,EAAeC,MAAf;AACA,eAAOA,MAAM,CAACK,CAAd;AACD;;AAED,aAAOC,SAAP;AACD,KAdI;AAeLF,IAAAA,GAAG,EAAE,CAACR,OAAD,EAAUS,CAAV,KAAgB;AACnBX,MAAAA,KAAK,CAACU,GAAN,CAAW,GAAEX,QAAS,GAAEG,OAAQ,EAAhC,EAAmC;AACjCS,QAAAA,CADiC;AAEjCJ,QAAAA,CAAC,EAAEC,IAAI,CAACC,GAAL;AAF8B,OAAnC;AAID;AApBI,GAAP;AAsBD;;AAED,SAASI,UAAT,CAAoBb,KAApB,EAA2B;AACzB;AACA,QAAMS,GAAG,GAAGD,IAAI,CAACC,GAAL,EAAZ;AACA,QAAMK,GAAG,GAAG,EAAZ;AACAd,EAAAA,KAAK,CAACG,OAAN,CAAc,CAACE,GAAD,EAAM;AAClBE,IAAAA;AADkB,GAAN,KAER;AACJE,IAAAA,GAAG,GAAGF,CAAN,GAAUV,aAAV,IAA2BiB,GAAG,CAACC,IAAJ,CAASV,GAAT,CAA3B;AACD,GAJD,EAJyB,CAQrB;;AAEJS,EAAAA,GAAG,CAACX,OAAJ,CAAYE,GAAG,IAAIL,KAAK,CAACC,GAAN,CAAUI,GAAV,CAAnB;AACD;;AAED,SAASZ,cAAT,CAAwBuB,MAAM,GAAG,EAAjC,EAAqChB,KAArC,EAA4C;AAC1CT,EAAAA,OAAO,CAACG,WAAR,GAAsBA,WAAW,GAAGM,KAAK,GAAGF,SAAS,CAAE,UAASkB,MAAO,GAAlB,EAAsBhB,KAAtB,CAAZ,GAA2CL,UAAU,CAACsB,eAA/F;;AAEA,MAAIjB,KAAJ,EAAW;AACTa,IAAAA,UAAU,CAACb,KAAD,CAAV;AACD;AACF;;AAEDP,cAAc","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setDeriveCache = setDeriveCache;\nexports.deriveCache = void 0;\n\nvar _cacheImpl = require(\"./cacheImpl\");\n\n// Copyright 2017-2020 @polkadot/api-derive authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nconst CHACHE_EXPIRY = 7 * (24 * 60) * (60 * 1000);\nlet deriveCache;\nexports.deriveCache = deriveCache;\n\nfunction wrapCache(keyStart, cache) {\n  return {\n    del: partial => cache.del(`${keyStart}${partial}`),\n    forEach: cache.forEach,\n    get: partial => {\n      const key = `${keyStart}${partial}`;\n      const cached = cache.get(key);\n\n      if (cached) {\n        cached.x = Date.now();\n        cache.set(key, cached);\n        return cached.v;\n      }\n\n      return undefined;\n    },\n    set: (partial, v) => {\n      cache.set(`${keyStart}${partial}`, {\n        v,\n        x: Date.now()\n      });\n    }\n  };\n}\n\nfunction clearCache(cache) {\n  // clear all expired values\n  const now = Date.now();\n  const all = [];\n  cache.forEach((key, {\n    x\n  }) => {\n    now - x > CHACHE_EXPIRY && all.push(key);\n  }); // don't do delete inside loop, just in-case\n\n  all.forEach(key => cache.del(key));\n}\n\nfunction setDeriveCache(prefix = '', cache) {\n  exports.deriveCache = deriveCache = cache ? wrapCache(`derive:${prefix}:`, cache) : _cacheImpl.deriveNoopCache;\n\n  if (cache) {\n    clearCache(cache);\n  }\n}\n\nsetDeriveCache();"]},"metadata":{},"sourceType":"script"}