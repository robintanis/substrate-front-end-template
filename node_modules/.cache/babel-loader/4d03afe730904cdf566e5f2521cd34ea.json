{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = u8aToHex; // Copyright 2017-2020 @polkadot/util authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\nconst ALPHABET = new Array(256);\n\nfor (let n = 0; n < 256; ++n) {\n  ALPHABET[n] = n.toString(16).padStart(2, '0');\n}\n/**\n * @name u8aToHex\n * @summary Creates a hex string from a Uint8Array object.\n * @description\n * `UInt8Array` input values return the actual hex string. `null` or `undefined` values returns an `0x` string.\n * @example\n * <BR>\n *\n * ```javascript\n * import { u8aToHex } from '@polkadot/util';\n *\n * u8aToHex(new Uint8Array([0x68, 0x65, 0x6c, 0x6c, 0xf])); // 0x68656c0f\n * ```\n */\n\n\nfunction u8aToHex(value, bitLength = -1, isPrefixed = true) {\n  const prefix = isPrefixed ? '0x' : '';\n\n  if (!(value === null || value === void 0 ? void 0 : value.length)) {\n    return prefix;\n  }\n\n  const byteLength = Math.ceil(bitLength / 8);\n\n  if (byteLength > 0 && value.length > byteLength) {\n    const halfLength = Math.ceil(byteLength / 2);\n    return `${u8aToHex(value.subarray(0, halfLength), -1, isPrefixed)}…${u8aToHex(value.subarray(value.length - halfLength), -1, false)}`;\n  }\n\n  const result = new Array(value.length);\n\n  for (let i = 0; i < value.length; i++) {\n    result[i] = ALPHABET[value[i]];\n  }\n\n  return prefix + result.join('');\n}","map":{"version":3,"sources":["/home/robin/substrate-front-end-template/node_modules/@polkadot/util/u8a/toHex.js"],"names":["Object","defineProperty","exports","value","default","u8aToHex","ALPHABET","Array","n","toString","padStart","bitLength","isPrefixed","prefix","length","byteLength","Math","ceil","halfLength","subarray","result","i","join"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,OAAR,GAAkBC,QAAlB,C,CACA;AACA;;AACA,MAAMC,QAAQ,GAAG,IAAIC,KAAJ,CAAU,GAAV,CAAjB;;AAEA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,GAApB,EAAyB,EAAEA,CAA3B,EAA8B;AAC5BF,EAAAA,QAAQ,CAACE,CAAD,CAAR,GAAcA,CAAC,CAACC,QAAF,CAAW,EAAX,EAAeC,QAAf,CAAwB,CAAxB,EAA2B,GAA3B,CAAd;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,SAASL,QAAT,CAAkBF,KAAlB,EAAyBQ,SAAS,GAAG,CAAC,CAAtC,EAAyCC,UAAU,GAAG,IAAtD,EAA4D;AAC1D,QAAMC,MAAM,GAAGD,UAAU,GAAG,IAAH,GAAU,EAAnC;;AAEA,MAAI,EAAET,KAAK,KAAK,IAAV,IAAkBA,KAAK,KAAK,KAAK,CAAjC,GAAqC,KAAK,CAA1C,GAA8CA,KAAK,CAACW,MAAtD,CAAJ,EAAmE;AACjE,WAAOD,MAAP;AACD;;AAED,QAAME,UAAU,GAAGC,IAAI,CAACC,IAAL,CAAUN,SAAS,GAAG,CAAtB,CAAnB;;AAEA,MAAII,UAAU,GAAG,CAAb,IAAkBZ,KAAK,CAACW,MAAN,GAAeC,UAArC,EAAiD;AAC/C,UAAMG,UAAU,GAAGF,IAAI,CAACC,IAAL,CAAUF,UAAU,GAAG,CAAvB,CAAnB;AACA,WAAQ,GAAEV,QAAQ,CAACF,KAAK,CAACgB,QAAN,CAAe,CAAf,EAAkBD,UAAlB,CAAD,EAAgC,CAAC,CAAjC,EAAoCN,UAApC,CAAgD,IAAGP,QAAQ,CAACF,KAAK,CAACgB,QAAN,CAAehB,KAAK,CAACW,MAAN,GAAeI,UAA9B,CAAD,EAA4C,CAAC,CAA7C,EAAgD,KAAhD,CAAuD,EAApI;AACD;;AAED,QAAME,MAAM,GAAG,IAAIb,KAAJ,CAAUJ,KAAK,CAACW,MAAhB,CAAf;;AAEA,OAAK,IAAIO,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGlB,KAAK,CAACW,MAA1B,EAAkCO,CAAC,EAAnC,EAAuC;AACrCD,IAAAA,MAAM,CAACC,CAAD,CAAN,GAAYf,QAAQ,CAACH,KAAK,CAACkB,CAAD,CAAN,CAApB;AACD;;AAED,SAAOR,MAAM,GAAGO,MAAM,CAACE,IAAP,CAAY,EAAZ,CAAhB;AACD","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = u8aToHex;\n// Copyright 2017-2020 @polkadot/util authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nconst ALPHABET = new Array(256);\n\nfor (let n = 0; n < 256; ++n) {\n  ALPHABET[n] = n.toString(16).padStart(2, '0');\n}\n/**\n * @name u8aToHex\n * @summary Creates a hex string from a Uint8Array object.\n * @description\n * `UInt8Array` input values return the actual hex string. `null` or `undefined` values returns an `0x` string.\n * @example\n * <BR>\n *\n * ```javascript\n * import { u8aToHex } from '@polkadot/util';\n *\n * u8aToHex(new Uint8Array([0x68, 0x65, 0x6c, 0x6c, 0xf])); // 0x68656c0f\n * ```\n */\n\n\nfunction u8aToHex(value, bitLength = -1, isPrefixed = true) {\n  const prefix = isPrefixed ? '0x' : '';\n\n  if (!(value === null || value === void 0 ? void 0 : value.length)) {\n    return prefix;\n  }\n\n  const byteLength = Math.ceil(bitLength / 8);\n\n  if (byteLength > 0 && value.length > byteLength) {\n    const halfLength = Math.ceil(byteLength / 2);\n    return `${u8aToHex(value.subarray(0, halfLength), -1, isPrefixed)}…${u8aToHex(value.subarray(value.length - halfLength), -1, false)}`;\n  }\n\n  const result = new Array(value.length);\n\n  for (let i = 0; i < value.length; i++) {\n    result[i] = ALPHABET[value[i]];\n  }\n\n  return prefix + result.join('');\n}"]},"metadata":{},"sourceType":"script"}