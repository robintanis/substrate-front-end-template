{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _util = require(\"@polkadot/util\");\n\nvar _Compact = _interopRequireDefault(require(\"./Compact\"));\n\nvar _utils = require(\"./utils\");\n\nvar _AbstractArray = _interopRequireDefault(require(\"./AbstractArray\")); // Copyright 2017-2020 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nconst MAX_LENGTH = 64 * 1024;\n/**\n * @name Vec\n * @description\n * This manages codec arrays. Internally it keeps track of the length (as decoded) and allows\n * construction with the passed `Type` in the constructor. It is an extension to Array, providing\n * specific encoding/decoding on top of the base type.\n */\n\nclass Vec extends _AbstractArray.default {\n  constructor(registry, Type, value = []) {\n    const Clazz = (0, _utils.typeToConstructor)(registry, Type);\n    super(registry, ...Vec.decodeVec(registry, Clazz, value));\n    this._Type = void 0;\n    this._Type = Clazz;\n  }\n  /** @internal */\n\n\n  static decodeVec(registry, Type, value) {\n    if (Array.isArray(value)) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n      return value.map((entry, index) => {\n        try {\n          return entry instanceof Type ? entry : new Type(registry, entry);\n        } catch (error) {\n          console.error(`Unable to decode Vec on index ${index}`, error.message);\n          throw error;\n        }\n      });\n    }\n\n    const u8a = (0, _util.u8aToU8a)(value);\n\n    const [offset, length] = _Compact.default.decodeU8a(u8a);\n\n    (0, _util.assert)(length.lten(MAX_LENGTH), `Vec length ${length.toString()} exceeds ${MAX_LENGTH}`);\n    return (0, _utils.decodeU8a)(registry, u8a.subarray(offset), new Array(length.toNumber()).fill(Type));\n  }\n\n  static with(Type) {\n    return class extends Vec {\n      constructor(registry, value) {\n        super(registry, Type, value);\n      }\n\n    };\n  }\n  /**\n   * @description The type for the items\n   */\n\n\n  get Type() {\n    return this._Type.name;\n  }\n  /**\n   * @description Finds the index of the value in the array\n   */\n\n\n  indexOf(_other) {\n    // convert type first, this removes overhead from the eq\n    const other = _other instanceof this._Type ? _other : new this._Type(this.registry, _other);\n\n    for (let i = 0; i < this.length; i++) {\n      if (other.eq(this[i])) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType() {\n    return `Vec<${this.registry.getClassName(this._Type) || new this._Type(this.registry).toRawType()}>`;\n  }\n\n}\n\nexports.default = Vec;","map":{"version":3,"sources":["/home/robin/substrate-front-end-template/node_modules/@polkadot/types/codec/Vec.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","default","_util","_Compact","_utils","_AbstractArray","MAX_LENGTH","Vec","constructor","registry","Type","Clazz","typeToConstructor","decodeVec","_Type","Array","isArray","map","entry","index","error","console","message","u8a","u8aToU8a","offset","length","decodeU8a","assert","lten","toString","subarray","toNumber","fill","with","name","indexOf","_other","other","i","eq","toRawType","getClassName"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _util = require(\"@polkadot/util\");\n\nvar _Compact = _interopRequireDefault(require(\"./Compact\"));\n\nvar _utils = require(\"./utils\");\n\nvar _AbstractArray = _interopRequireDefault(require(\"./AbstractArray\"));\n\n// Copyright 2017-2020 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nconst MAX_LENGTH = 64 * 1024;\n/**\n * @name Vec\n * @description\n * This manages codec arrays. Internally it keeps track of the length (as decoded) and allows\n * construction with the passed `Type` in the constructor. It is an extension to Array, providing\n * specific encoding/decoding on top of the base type.\n */\n\nclass Vec extends _AbstractArray.default {\n  constructor(registry, Type, value = []) {\n    const Clazz = (0, _utils.typeToConstructor)(registry, Type);\n    super(registry, ...Vec.decodeVec(registry, Clazz, value));\n    this._Type = void 0;\n    this._Type = Clazz;\n  }\n  /** @internal */\n\n\n  static decodeVec(registry, Type, value) {\n    if (Array.isArray(value)) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n      return value.map((entry, index) => {\n        try {\n          return entry instanceof Type ? entry : new Type(registry, entry);\n        } catch (error) {\n          console.error(`Unable to decode Vec on index ${index}`, error.message);\n          throw error;\n        }\n      });\n    }\n\n    const u8a = (0, _util.u8aToU8a)(value);\n\n    const [offset, length] = _Compact.default.decodeU8a(u8a);\n\n    (0, _util.assert)(length.lten(MAX_LENGTH), `Vec length ${length.toString()} exceeds ${MAX_LENGTH}`);\n    return (0, _utils.decodeU8a)(registry, u8a.subarray(offset), new Array(length.toNumber()).fill(Type));\n  }\n\n  static with(Type) {\n    return class extends Vec {\n      constructor(registry, value) {\n        super(registry, Type, value);\n      }\n\n    };\n  }\n  /**\n   * @description The type for the items\n   */\n\n\n  get Type() {\n    return this._Type.name;\n  }\n  /**\n   * @description Finds the index of the value in the array\n   */\n\n\n  indexOf(_other) {\n    // convert type first, this removes overhead from the eq\n    const other = _other instanceof this._Type ? _other : new this._Type(this.registry, _other);\n\n    for (let i = 0; i < this.length; i++) {\n      if (other.eq(this[i])) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType() {\n    return `Vec<${this.registry.getClassName(this._Type) || new this._Type(this.registry).toRawType()}>`;\n  }\n\n}\n\nexports.default = Vec;"]},"metadata":{},"sourceType":"script"}