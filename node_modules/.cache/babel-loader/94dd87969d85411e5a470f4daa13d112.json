{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = ethereumEncode;\n\nvar _util = require(\"@polkadot/util\");\n\nvar _keccak = require(\"../keccak\");\n\nvar _secp256k = require(\"../secp256k1\"); // Copyright 2017-2020 @polkadot/util-crypto authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nfunction getH160(u8a) {\n  if ([33, 65].includes(u8a.length)) {\n    u8a = (0, _keccak.keccakAsU8a)((0, _secp256k.secp256k1Expand)(u8a));\n  }\n\n  return u8a.slice(-20);\n}\n\nfunction ethereumEncode(addressOrPublic) {\n  if (!addressOrPublic) {\n    return '0x';\n  }\n\n  const u8aAddress = (0, _util.u8aToU8a)(addressOrPublic);\n  (0, _util.assert)([20, 32, 33, 65].includes(u8aAddress.length), 'Invalid address or publicKey passed');\n  const address = (0, _util.u8aToHex)(getH160(u8aAddress), -1, false);\n  const hash = (0, _util.u8aToHex)((0, _keccak.keccakAsU8a)(address), -1, false);\n  let result = '';\n\n  for (let index = 0; index < 40; index++) {\n    result = `${result}${parseInt(hash[index], 16) > 7 ? address[index].toUpperCase() : address[index]}`;\n  }\n\n  return `0x${result}`;\n}","map":{"version":3,"sources":["/home/robin/substrate-front-end-template/node_modules/@polkadot/util-crypto/ethereum/encode.js"],"names":["Object","defineProperty","exports","value","default","ethereumEncode","_util","require","_keccak","_secp256k","getH160","u8a","includes","length","keccakAsU8a","secp256k1Expand","slice","addressOrPublic","u8aAddress","u8aToU8a","assert","address","u8aToHex","hash","result","index","parseInt","toUpperCase"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,OAAR,GAAkBC,cAAlB;;AAEA,IAAIC,KAAK,GAAGC,OAAO,CAAC,gBAAD,CAAnB;;AAEA,IAAIC,OAAO,GAAGD,OAAO,CAAC,WAAD,CAArB;;AAEA,IAAIE,SAAS,GAAGF,OAAO,CAAC,cAAD,CAAvB,C,CAEA;AACA;;;AACA,SAASG,OAAT,CAAiBC,GAAjB,EAAsB;AACpB,MAAI,CAAC,EAAD,EAAK,EAAL,EAASC,QAAT,CAAkBD,GAAG,CAACE,MAAtB,CAAJ,EAAmC;AACjCF,IAAAA,GAAG,GAAG,CAAC,GAAGH,OAAO,CAACM,WAAZ,EAAyB,CAAC,GAAGL,SAAS,CAACM,eAAd,EAA+BJ,GAA/B,CAAzB,CAAN;AACD;;AAED,SAAOA,GAAG,CAACK,KAAJ,CAAU,CAAC,EAAX,CAAP;AACD;;AAED,SAASX,cAAT,CAAwBY,eAAxB,EAAyC;AACvC,MAAI,CAACA,eAAL,EAAsB;AACpB,WAAO,IAAP;AACD;;AAED,QAAMC,UAAU,GAAG,CAAC,GAAGZ,KAAK,CAACa,QAAV,EAAoBF,eAApB,CAAnB;AACA,GAAC,GAAGX,KAAK,CAACc,MAAV,EAAkB,CAAC,EAAD,EAAK,EAAL,EAAS,EAAT,EAAa,EAAb,EAAiBR,QAAjB,CAA0BM,UAAU,CAACL,MAArC,CAAlB,EAAgE,qCAAhE;AACA,QAAMQ,OAAO,GAAG,CAAC,GAAGf,KAAK,CAACgB,QAAV,EAAoBZ,OAAO,CAACQ,UAAD,CAA3B,EAAyC,CAAC,CAA1C,EAA6C,KAA7C,CAAhB;AACA,QAAMK,IAAI,GAAG,CAAC,GAAGjB,KAAK,CAACgB,QAAV,EAAoB,CAAC,GAAGd,OAAO,CAACM,WAAZ,EAAyBO,OAAzB,CAApB,EAAuD,CAAC,CAAxD,EAA2D,KAA3D,CAAb;AACA,MAAIG,MAAM,GAAG,EAAb;;AAEA,OAAK,IAAIC,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAG,EAA5B,EAAgCA,KAAK,EAArC,EAAyC;AACvCD,IAAAA,MAAM,GAAI,GAAEA,MAAO,GAAEE,QAAQ,CAACH,IAAI,CAACE,KAAD,CAAL,EAAc,EAAd,CAAR,GAA4B,CAA5B,GAAgCJ,OAAO,CAACI,KAAD,CAAP,CAAeE,WAAf,EAAhC,GAA+DN,OAAO,CAACI,KAAD,CAAQ,EAAnG;AACD;;AAED,SAAQ,KAAID,MAAO,EAAnB;AACD","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = ethereumEncode;\n\nvar _util = require(\"@polkadot/util\");\n\nvar _keccak = require(\"../keccak\");\n\nvar _secp256k = require(\"../secp256k1\");\n\n// Copyright 2017-2020 @polkadot/util-crypto authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nfunction getH160(u8a) {\n  if ([33, 65].includes(u8a.length)) {\n    u8a = (0, _keccak.keccakAsU8a)((0, _secp256k.secp256k1Expand)(u8a));\n  }\n\n  return u8a.slice(-20);\n}\n\nfunction ethereumEncode(addressOrPublic) {\n  if (!addressOrPublic) {\n    return '0x';\n  }\n\n  const u8aAddress = (0, _util.u8aToU8a)(addressOrPublic);\n  (0, _util.assert)([20, 32, 33, 65].includes(u8aAddress.length), 'Invalid address or publicKey passed');\n  const address = (0, _util.u8aToHex)(getH160(u8aAddress), -1, false);\n  const hash = (0, _util.u8aToHex)((0, _keccak.keccakAsU8a)(address), -1, false);\n  let result = '';\n\n  for (let index = 0; index < 40; index++) {\n    result = `${result}${parseInt(hash[index], 16) > 7 ? address[index].toUpperCase() : address[index]}`;\n  }\n\n  return `0x${result}`;\n}"]},"metadata":{},"sourceType":"script"}