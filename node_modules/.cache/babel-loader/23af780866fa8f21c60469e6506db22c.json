{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.extractStorageArgs = extractStorageArgs;\n\nvar _util = require(\"@polkadot/util\"); // Copyright 2017-2019 @polkadot/api authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nfunction sig({\n  method,\n  section\n}, ...args) {\n  return `${section}.${method}(${args.join(', ')})`;\n}\n\nfunction doDoubleMap(creator, args) {\n  const {\n    key1,\n    key2\n  } = creator.meta.type.asDoubleMap;\n  (0, _util.assert)(args.length === 2, `${sig(creator, key1, key2)} is a doublemap, requiring 2 arguments, ${args.length} found`); // pass as tuple\n\n  return [creator, args];\n}\n\nfunction doMap(creator, args) {\n  const {\n    key\n  } = creator.meta.type.asMap;\n  (0, _util.assert)(args.length === 1, `${sig(creator, key)} is a map, requiring 1 argument, ${args.length} found`); // expand\n\n  return args.length ? [creator, args[0]] : [creator];\n} // sets up the arguments in the form of [creator, args] ready to be used in a storage\n// call. Additionally, it verifies that the correct number of arguments have been passed\n\n\nfunction extractStorageArgs(creator, _args) {\n  const args = _args.filter(arg => !(0, _util.isUndefined)(arg));\n\n  if (creator.meta.type.isDoubleMap) {\n    return doDoubleMap(creator, args);\n  } else if (creator.meta.type.isMap) {\n    return doMap(creator, args);\n  }\n\n  (0, _util.assert)(args.length === 0, `${sig(creator)} does not take any arguments, ${args.length} found`); // no args\n\n  return [creator];\n}","map":{"version":3,"sources":["/home/robin/substrate-front-end-template/node_modules/@polkadot/api/util/validate.js"],"names":["Object","defineProperty","exports","value","extractStorageArgs","_util","require","sig","method","section","args","join","doDoubleMap","creator","key1","key2","meta","type","asDoubleMap","assert","length","doMap","key","asMap","_args","filter","arg","isUndefined","isDoubleMap","isMap"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,kBAAR,GAA6BA,kBAA7B;;AAEA,IAAIC,KAAK,GAAGC,OAAO,CAAC,gBAAD,CAAnB,C,CAEA;AACA;;;AACA,SAASC,GAAT,CAAa;AACXC,EAAAA,MADW;AAEXC,EAAAA;AAFW,CAAb,EAGG,GAAGC,IAHN,EAGY;AACV,SAAQ,GAAED,OAAQ,IAAGD,MAAO,IAAGE,IAAI,CAACC,IAAL,CAAU,IAAV,CAAgB,GAA/C;AACD;;AAED,SAASC,WAAT,CAAqBC,OAArB,EAA8BH,IAA9B,EAAoC;AAClC,QAAM;AACJI,IAAAA,IADI;AAEJC,IAAAA;AAFI,MAGFF,OAAO,CAACG,IAAR,CAAaC,IAAb,CAAkBC,WAHtB;AAIA,GAAC,GAAGb,KAAK,CAACc,MAAV,EAAkBT,IAAI,CAACU,MAAL,KAAgB,CAAlC,EAAsC,GAAEb,GAAG,CAACM,OAAD,EAAUC,IAAV,EAAgBC,IAAhB,CAAsB,2CAA0CL,IAAI,CAACU,MAAO,QAAvH,EALkC,CAK+F;;AAEjI,SAAO,CAACP,OAAD,EAAUH,IAAV,CAAP;AACD;;AAED,SAASW,KAAT,CAAeR,OAAf,EAAwBH,IAAxB,EAA8B;AAC5B,QAAM;AACJY,IAAAA;AADI,MAEFT,OAAO,CAACG,IAAR,CAAaC,IAAb,CAAkBM,KAFtB;AAGA,GAAC,GAAGlB,KAAK,CAACc,MAAV,EAAkBT,IAAI,CAACU,MAAL,KAAgB,CAAlC,EAAsC,GAAEb,GAAG,CAACM,OAAD,EAAUS,GAAV,CAAe,oCAAmCZ,IAAI,CAACU,MAAO,QAAzG,EAJ4B,CAIuF;;AAEnH,SAAOV,IAAI,CAACU,MAAL,GAAc,CAACP,OAAD,EAAUH,IAAI,CAAC,CAAD,CAAd,CAAd,GAAmC,CAACG,OAAD,CAA1C;AACD,C,CAAC;AACF;;;AAGA,SAAST,kBAAT,CAA4BS,OAA5B,EAAqCW,KAArC,EAA4C;AAC1C,QAAMd,IAAI,GAAGc,KAAK,CAACC,MAAN,CAAaC,GAAG,IAAI,CAAC,CAAC,GAAGrB,KAAK,CAACsB,WAAV,EAAuBD,GAAvB,CAArB,CAAb;;AAEA,MAAIb,OAAO,CAACG,IAAR,CAAaC,IAAb,CAAkBW,WAAtB,EAAmC;AACjC,WAAOhB,WAAW,CAACC,OAAD,EAAUH,IAAV,CAAlB;AACD,GAFD,MAEO,IAAIG,OAAO,CAACG,IAAR,CAAaC,IAAb,CAAkBY,KAAtB,EAA6B;AAClC,WAAOR,KAAK,CAACR,OAAD,EAAUH,IAAV,CAAZ;AACD;;AAED,GAAC,GAAGL,KAAK,CAACc,MAAV,EAAkBT,IAAI,CAACU,MAAL,KAAgB,CAAlC,EAAsC,GAAEb,GAAG,CAACM,OAAD,CAAU,iCAAgCH,IAAI,CAACU,MAAO,QAAjG,EAT0C,CASiE;;AAE3G,SAAO,CAACP,OAAD,CAAP;AACD","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.extractStorageArgs = extractStorageArgs;\n\nvar _util = require(\"@polkadot/util\");\n\n// Copyright 2017-2019 @polkadot/api authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nfunction sig({\n  method,\n  section\n}, ...args) {\n  return `${section}.${method}(${args.join(', ')})`;\n}\n\nfunction doDoubleMap(creator, args) {\n  const {\n    key1,\n    key2\n  } = creator.meta.type.asDoubleMap;\n  (0, _util.assert)(args.length === 2, `${sig(creator, key1, key2)} is a doublemap, requiring 2 arguments, ${args.length} found`); // pass as tuple\n\n  return [creator, args];\n}\n\nfunction doMap(creator, args) {\n  const {\n    key\n  } = creator.meta.type.asMap;\n  (0, _util.assert)(args.length === 1, `${sig(creator, key)} is a map, requiring 1 argument, ${args.length} found`); // expand\n\n  return args.length ? [creator, args[0]] : [creator];\n} // sets up the arguments in the form of [creator, args] ready to be used in a storage\n// call. Additionally, it verifies that the correct number of arguments have been passed\n\n\nfunction extractStorageArgs(creator, _args) {\n  const args = _args.filter(arg => !(0, _util.isUndefined)(arg));\n\n  if (creator.meta.type.isDoubleMap) {\n    return doDoubleMap(creator, args);\n  } else if (creator.meta.type.isMap) {\n    return doMap(creator, args);\n  }\n\n  (0, _util.assert)(args.length === 0, `${sig(creator)} does not take any arguments, ${args.length} found`); // no args\n\n  return [creator];\n}"]},"metadata":{},"sourceType":"script"}