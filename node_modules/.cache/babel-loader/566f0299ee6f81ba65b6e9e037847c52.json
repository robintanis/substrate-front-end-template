{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findClosing = findClosing;\nexports.alias = alias;\nexports.cleanupCompact = cleanupCompact;\nexports.flattenSingleTuple = flattenSingleTuple;\nexports.removeColons = removeColons;\nexports.removeGenerics = removeGenerics;\nexports.removePairOf = removePairOf;\nexports.removeTraits = removeTraits;\nexports.removeWrap = removeWrap;\nexports.default = sanitize; // Copyright 2017-2020 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\nconst ALLOWED_BOXES = ['BTreeMap', 'BTreeSet', 'Compact', 'DoNotConstruct', 'HashMap', 'Int', 'Linkage', 'Result', 'Option', 'UInt', 'Vec'];\nconst BOX_PRECEDING = ['<', '(', '[', '\"', ',', ' ']; // start of vec, tuple, fixed array, part of struct def or in tuple\n\nconst mappings = [// alias <T::InherentOfflineReport as InherentOfflineReport>::Inherent -> InherentOfflineReport\nalias(['<T::InherentOfflineReport as InherentOfflineReport>::Inherent'], 'InherentOfflineReport', false), // <T::Balance as HasCompact>\ncleanupCompact(), // Remove all the trait prefixes\nremoveTraits(), // remove PairOf<T> -> (T, T)\nremovePairOf(), // remove boxing, `Box<Proposal>` -> `Proposal`\nremoveWrap('Box'), // remove generics, `MisbehaviorReport<Hash, BlockNumber>` -> `MisbehaviorReport`\nremoveGenerics(), // alias String -> Text (compat with jsonrpc methods)\nalias(['String'], 'Text'), // alias Vec<u8> -> Bytes\nalias(['Vec<u8>', '&\\\\[u8\\\\]'], 'Bytes'), // alias RawAddress -> Address\nalias(['RawAddress'], 'Address'), // lookups, mapped to Address/AccountId as appropriate in runtime\nalias(['Lookup::Source'], 'LookupSource'), alias(['Lookup::Target'], 'LookupTarget'), // HACK duplication between contracts & primitives, however contracts prefixed with exec\nalias(['exec::StorageKey'], 'ContractStorageKey'), // flattens tuples with one value, `(AccountId)` -> `AccountId`\nflattenSingleTuple(), // converts ::Type to Type, <T as Trait<I>>::Proposal -> Proposal\nremoveColons()]; // given a starting index, find the closing >\n\nfunction findClosing(value, start) {\n  let depth = 0;\n\n  for (let index = start; index < value.length; index++) {\n    if (value[index] === '>') {\n      if (!depth) {\n        return index;\n      }\n\n      depth--;\n    } else if (value[index] === '<') {\n      depth++;\n    }\n  }\n\n  throw new Error(`Unable to find closing matching <> on '${value}' (start ${start})`);\n}\n\nfunction alias(src, dest, withChecks = true) {\n  return value => {\n    return src.reduce((value, src) => {\n      return value.replace(new RegExp(`(^${src}|${BOX_PRECEDING.map(box => `\\\\${box}${src}`).join('|')})`, 'g'), src => withChecks && BOX_PRECEDING.includes(src[0]) ? `${src[0]}${dest}` : dest);\n    }, value);\n  };\n}\n\nfunction cleanupCompact() {\n  return value => {\n    for (let index = 0; index < value.length; index++) {\n      if (value[index] !== '<') {\n        continue;\n      }\n\n      const end = findClosing(value, index + 1) - 14;\n\n      if (value.substr(end, 14) === ' as HasCompact') {\n        value = `Compact<${value.substr(index + 1, end - index - 1)}>`;\n      }\n    }\n\n    return value;\n  };\n}\n\nfunction flattenSingleTuple() {\n  return value => {\n    return value.replace(/\\(([^,]+)\\)/, '$1');\n  };\n}\n\nfunction removeColons() {\n  return (value, {\n    allowNamespaces\n  } = {}) => {\n    let index = 0;\n\n    while (index !== -1) {\n      index = value.indexOf('::');\n\n      if (index === 0) {\n        value = value.substr(2);\n      } else if (index !== -1) {\n        if (allowNamespaces) {\n          return value;\n        }\n\n        let start = index;\n\n        while (start !== -1 && !BOX_PRECEDING.includes(value[start])) {\n          start--;\n        }\n\n        value = `${value.substr(0, start + 1)}${value.substr(index + 2)}`;\n      }\n    }\n\n    return value;\n  };\n}\n\nfunction removeGenerics() {\n  return value => {\n    for (let index = 0; index < value.length; index++) {\n      if (value[index] === '<') {\n        // check against the allowed wrappers, be it Vec<..>, Option<...> ...\n        const box = ALLOWED_BOXES.find(box => {\n          const start = index - box.length;\n          return start >= 0 && value.substr(start, box.length) === box && ( // make sure it is stand-alone, i.e. don't catch ElectionResult<...> as Result<...>\n          start === 0 || BOX_PRECEDING.includes(value[start - 1]));\n        }); // we have not found anything, unwrap generic innards\n\n        if (!box) {\n          const end = findClosing(value, index + 1);\n          value = `${value.substr(0, index)}${value.substr(end + 1)}`;\n        }\n      }\n    }\n\n    return value;\n  };\n} // remove the PairOf wrappers\n\n\nfunction removePairOf() {\n  return value => {\n    for (let index = 0; index < value.length; index++) {\n      if (value.substr(index, 7) === 'PairOf<') {\n        const start = index + 7;\n        const end = findClosing(value, start);\n        const type = value.substr(start, end - start);\n        value = `${value.substr(0, index)}(${type},${type})${value.substr(end + 1)}`;\n      }\n    }\n\n    return value;\n  };\n} // remove the type traits\n\n\nfunction removeTraits() {\n  return value => {\n    return value // remove all whitespaces\n    .replace(/\\s/g, '') // anything `T::<type>` to end up as `<type>`\n    .replace(/(T|Self)::/g, '') // replace `<T as Trait>::` (whitespaces were removed above)\n    .replace(/<(T|Self)asTrait>::/g, '') // replace `<T as something::Trait>::` (whitespaces were removed above)\n    .replace(/<Tas[a-z]+::Trait>::/g, '') // replace <Lookup as StaticLookup>\n    .replace(/<LookupasStaticLookup>/g, 'Lookup') // replace `<...>::Type`\n    .replace(/::Type/g, '');\n  };\n} // remove wrapping values, i.e. Box<Proposal> -> Proposal\n\n\nfunction removeWrap(_check) {\n  const check = `${_check}<`;\n  return value => {\n    let index = 0;\n\n    while (index !== -1) {\n      index = value.indexOf(check);\n\n      if (index !== -1) {\n        const start = index + check.length;\n        const end = findClosing(value, start);\n        value = `${value.substr(0, index)}${value.substr(start, end - start)}${value.substr(end + 1)}`;\n      }\n    }\n\n    return value;\n  };\n}\n\nfunction sanitize(value, options) {\n  return mappings.reduce((result, fn) => {\n    return fn(result, options);\n  }, value).trim();\n}","map":{"version":3,"sources":["/home/robin/substrate-front-end-template/node_modules/@polkadot/types/create/sanitize.js"],"names":["Object","defineProperty","exports","value","findClosing","alias","cleanupCompact","flattenSingleTuple","removeColons","removeGenerics","removePairOf","removeTraits","removeWrap","default","sanitize","ALLOWED_BOXES","BOX_PRECEDING","mappings","start","depth","index","length","Error","src","dest","withChecks","reduce","replace","RegExp","map","box","join","includes","end","substr","allowNamespaces","indexOf","find","type","_check","check","options","result","fn","trim"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findClosing = findClosing;\nexports.alias = alias;\nexports.cleanupCompact = cleanupCompact;\nexports.flattenSingleTuple = flattenSingleTuple;\nexports.removeColons = removeColons;\nexports.removeGenerics = removeGenerics;\nexports.removePairOf = removePairOf;\nexports.removeTraits = removeTraits;\nexports.removeWrap = removeWrap;\nexports.default = sanitize;\n// Copyright 2017-2020 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nconst ALLOWED_BOXES = ['BTreeMap', 'BTreeSet', 'Compact', 'DoNotConstruct', 'HashMap', 'Int', 'Linkage', 'Result', 'Option', 'UInt', 'Vec'];\nconst BOX_PRECEDING = ['<', '(', '[', '\"', ',', ' ']; // start of vec, tuple, fixed array, part of struct def or in tuple\n\nconst mappings = [// alias <T::InherentOfflineReport as InherentOfflineReport>::Inherent -> InherentOfflineReport\nalias(['<T::InherentOfflineReport as InherentOfflineReport>::Inherent'], 'InherentOfflineReport', false), // <T::Balance as HasCompact>\ncleanupCompact(), // Remove all the trait prefixes\nremoveTraits(), // remove PairOf<T> -> (T, T)\nremovePairOf(), // remove boxing, `Box<Proposal>` -> `Proposal`\nremoveWrap('Box'), // remove generics, `MisbehaviorReport<Hash, BlockNumber>` -> `MisbehaviorReport`\nremoveGenerics(), // alias String -> Text (compat with jsonrpc methods)\nalias(['String'], 'Text'), // alias Vec<u8> -> Bytes\nalias(['Vec<u8>', '&\\\\[u8\\\\]'], 'Bytes'), // alias RawAddress -> Address\nalias(['RawAddress'], 'Address'), // lookups, mapped to Address/AccountId as appropriate in runtime\nalias(['Lookup::Source'], 'LookupSource'), alias(['Lookup::Target'], 'LookupTarget'), // HACK duplication between contracts & primitives, however contracts prefixed with exec\nalias(['exec::StorageKey'], 'ContractStorageKey'), // flattens tuples with one value, `(AccountId)` -> `AccountId`\nflattenSingleTuple(), // converts ::Type to Type, <T as Trait<I>>::Proposal -> Proposal\nremoveColons()]; // given a starting index, find the closing >\n\nfunction findClosing(value, start) {\n  let depth = 0;\n\n  for (let index = start; index < value.length; index++) {\n    if (value[index] === '>') {\n      if (!depth) {\n        return index;\n      }\n\n      depth--;\n    } else if (value[index] === '<') {\n      depth++;\n    }\n  }\n\n  throw new Error(`Unable to find closing matching <> on '${value}' (start ${start})`);\n}\n\nfunction alias(src, dest, withChecks = true) {\n  return value => {\n    return src.reduce((value, src) => {\n      return value.replace(new RegExp(`(^${src}|${BOX_PRECEDING.map(box => `\\\\${box}${src}`).join('|')})`, 'g'), src => withChecks && BOX_PRECEDING.includes(src[0]) ? `${src[0]}${dest}` : dest);\n    }, value);\n  };\n}\n\nfunction cleanupCompact() {\n  return value => {\n    for (let index = 0; index < value.length; index++) {\n      if (value[index] !== '<') {\n        continue;\n      }\n\n      const end = findClosing(value, index + 1) - 14;\n\n      if (value.substr(end, 14) === ' as HasCompact') {\n        value = `Compact<${value.substr(index + 1, end - index - 1)}>`;\n      }\n    }\n\n    return value;\n  };\n}\n\nfunction flattenSingleTuple() {\n  return value => {\n    return value.replace(/\\(([^,]+)\\)/, '$1');\n  };\n}\n\nfunction removeColons() {\n  return (value, {\n    allowNamespaces\n  } = {}) => {\n    let index = 0;\n\n    while (index !== -1) {\n      index = value.indexOf('::');\n\n      if (index === 0) {\n        value = value.substr(2);\n      } else if (index !== -1) {\n        if (allowNamespaces) {\n          return value;\n        }\n\n        let start = index;\n\n        while (start !== -1 && !BOX_PRECEDING.includes(value[start])) {\n          start--;\n        }\n\n        value = `${value.substr(0, start + 1)}${value.substr(index + 2)}`;\n      }\n    }\n\n    return value;\n  };\n}\n\nfunction removeGenerics() {\n  return value => {\n    for (let index = 0; index < value.length; index++) {\n      if (value[index] === '<') {\n        // check against the allowed wrappers, be it Vec<..>, Option<...> ...\n        const box = ALLOWED_BOXES.find(box => {\n          const start = index - box.length;\n          return start >= 0 && value.substr(start, box.length) === box && ( // make sure it is stand-alone, i.e. don't catch ElectionResult<...> as Result<...>\n          start === 0 || BOX_PRECEDING.includes(value[start - 1]));\n        }); // we have not found anything, unwrap generic innards\n\n        if (!box) {\n          const end = findClosing(value, index + 1);\n          value = `${value.substr(0, index)}${value.substr(end + 1)}`;\n        }\n      }\n    }\n\n    return value;\n  };\n} // remove the PairOf wrappers\n\n\nfunction removePairOf() {\n  return value => {\n    for (let index = 0; index < value.length; index++) {\n      if (value.substr(index, 7) === 'PairOf<') {\n        const start = index + 7;\n        const end = findClosing(value, start);\n        const type = value.substr(start, end - start);\n        value = `${value.substr(0, index)}(${type},${type})${value.substr(end + 1)}`;\n      }\n    }\n\n    return value;\n  };\n} // remove the type traits\n\n\nfunction removeTraits() {\n  return value => {\n    return value // remove all whitespaces\n    .replace(/\\s/g, '') // anything `T::<type>` to end up as `<type>`\n    .replace(/(T|Self)::/g, '') // replace `<T as Trait>::` (whitespaces were removed above)\n    .replace(/<(T|Self)asTrait>::/g, '') // replace `<T as something::Trait>::` (whitespaces were removed above)\n    .replace(/<Tas[a-z]+::Trait>::/g, '') // replace <Lookup as StaticLookup>\n    .replace(/<LookupasStaticLookup>/g, 'Lookup') // replace `<...>::Type`\n    .replace(/::Type/g, '');\n  };\n} // remove wrapping values, i.e. Box<Proposal> -> Proposal\n\n\nfunction removeWrap(_check) {\n  const check = `${_check}<`;\n  return value => {\n    let index = 0;\n\n    while (index !== -1) {\n      index = value.indexOf(check);\n\n      if (index !== -1) {\n        const start = index + check.length;\n        const end = findClosing(value, start);\n        value = `${value.substr(0, index)}${value.substr(start, end - start)}${value.substr(end + 1)}`;\n      }\n    }\n\n    return value;\n  };\n}\n\nfunction sanitize(value, options) {\n  return mappings.reduce((result, fn) => {\n    return fn(result, options);\n  }, value).trim();\n}"]},"metadata":{},"sourceType":"script"}