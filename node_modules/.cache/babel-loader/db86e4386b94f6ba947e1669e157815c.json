{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _util = require(\"@polkadot/util\");\n\nvar _Struct = _interopRequireDefault(require(\"../codec/Struct\")); // Copyright 2017-2020 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n// We explicitly cast the type here to get the actual TypeScript exports right\n// We can ignore the properties, added via Struct.with\n\n\nconst _Payload = _Struct.default.with({\n  address: 'Address',\n  blockHash: 'Hash',\n  blockNumber: 'BlockNumber',\n  era: 'ExtrinsicEra',\n  genesisHash: 'Hash',\n  method: 'Call',\n  nonce: 'Compact<Index>',\n  runtimeVersion: 'RuntimeVersion',\n  signedExtensions: 'Vec<Text>',\n  tip: 'Compact<Balance>',\n  version: 'u8'\n});\n/**\n * @name SignerPayload\n * @description\n * A generic signer payload that can be used for serialization between API and signer\n */\n\n\nclass SignerPayload extends _Payload {\n  /**\n   * @description Creates an representation of the structure as an ISignerPayload JSON\n   */\n  toPayload() {\n    const {\n      address,\n      blockHash,\n      blockNumber,\n      era,\n      genesisHash,\n      method,\n      nonce,\n      runtimeVersion: {\n        specVersion,\n        transactionVersion\n      },\n      signedExtensions,\n      tip,\n      version\n    } = this;\n    return {\n      address: address.toString(),\n      blockHash: blockHash.toHex(),\n      blockNumber: blockNumber.toHex(),\n      era: era.toHex(),\n      genesisHash: genesisHash.toHex(),\n      method: method.toHex(),\n      nonce: nonce.toHex(),\n      signedExtensions: signedExtensions.map(e => e.toString()),\n      specVersion: specVersion.toHex(),\n      tip: tip.toHex(),\n      transactionVersion: transactionVersion.toHex(),\n      version: version.toNumber()\n    };\n  }\n  /**\n   * @description Creates a representation of the payload in raw Exrinsic form\n   */\n\n\n  toRaw() {\n    const payload = this.toPayload(); // NOTE Explicitly pass the bare flag so the method is encoded un-prefixed (non-decodable, for signing only)\n\n    const data = (0, _util.u8aToHex)(this.registry.createType('ExtrinsicPayload', payload, {\n      version: payload.version\n    }).toU8a({\n      method: true\n    }));\n    return {\n      address: payload.address,\n      data,\n      type: 'payload'\n    };\n  }\n\n}\n\nexports.default = SignerPayload;","map":{"version":3,"sources":["/home/robin/substrate-front-end-template/node_modules/@polkadot/types/extrinsic/SignerPayload.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","default","_util","_Struct","_Payload","with","address","blockHash","blockNumber","era","genesisHash","method","nonce","runtimeVersion","signedExtensions","tip","version","SignerPayload","toPayload","specVersion","transactionVersion","toString","toHex","map","e","toNumber","toRaw","payload","data","u8aToHex","registry","createType","toU8a","type"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _util = require(\"@polkadot/util\");\n\nvar _Struct = _interopRequireDefault(require(\"../codec/Struct\"));\n\n// Copyright 2017-2020 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n// We explicitly cast the type here to get the actual TypeScript exports right\n// We can ignore the properties, added via Struct.with\nconst _Payload = _Struct.default.with({\n  address: 'Address',\n  blockHash: 'Hash',\n  blockNumber: 'BlockNumber',\n  era: 'ExtrinsicEra',\n  genesisHash: 'Hash',\n  method: 'Call',\n  nonce: 'Compact<Index>',\n  runtimeVersion: 'RuntimeVersion',\n  signedExtensions: 'Vec<Text>',\n  tip: 'Compact<Balance>',\n  version: 'u8'\n});\n/**\n * @name SignerPayload\n * @description\n * A generic signer payload that can be used for serialization between API and signer\n */\n\n\nclass SignerPayload extends _Payload {\n  /**\n   * @description Creates an representation of the structure as an ISignerPayload JSON\n   */\n  toPayload() {\n    const {\n      address,\n      blockHash,\n      blockNumber,\n      era,\n      genesisHash,\n      method,\n      nonce,\n      runtimeVersion: {\n        specVersion,\n        transactionVersion\n      },\n      signedExtensions,\n      tip,\n      version\n    } = this;\n    return {\n      address: address.toString(),\n      blockHash: blockHash.toHex(),\n      blockNumber: blockNumber.toHex(),\n      era: era.toHex(),\n      genesisHash: genesisHash.toHex(),\n      method: method.toHex(),\n      nonce: nonce.toHex(),\n      signedExtensions: signedExtensions.map(e => e.toString()),\n      specVersion: specVersion.toHex(),\n      tip: tip.toHex(),\n      transactionVersion: transactionVersion.toHex(),\n      version: version.toNumber()\n    };\n  }\n  /**\n   * @description Creates a representation of the payload in raw Exrinsic form\n   */\n\n\n  toRaw() {\n    const payload = this.toPayload(); // NOTE Explicitly pass the bare flag so the method is encoded un-prefixed (non-decodable, for signing only)\n\n    const data = (0, _util.u8aToHex)(this.registry.createType('ExtrinsicPayload', payload, {\n      version: payload.version\n    }).toU8a({\n      method: true\n    }));\n    return {\n      address: payload.address,\n      data,\n      type: 'payload'\n    };\n  }\n\n}\n\nexports.default = SignerPayload;"]},"metadata":{},"sourceType":"script"}