{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.unwrapStorageType = unwrapStorageType;\nexports.default = void 0;\n\nvar _util = require(\"@polkadot/util\");\n\nvar _Bytes = _interopRequireDefault(require(\"./Bytes\")); // Copyright 2017-2020 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nconst HASHER_MAP = {\n  // opaque\n  Blake2_128: [16, false],\n  // eslint-disable-line camelcase\n  Blake2_128Concat: [16, true],\n  // eslint-disable-line camelcase\n  Blake2_256: [32, false],\n  // eslint-disable-line camelcase\n  Identity: [0, true],\n  Twox128: [16, false],\n  Twox256: [32, false],\n  Twox64Concat: [8, true]\n};\n\nfunction getStorageType(type) {\n  if (type.isPlain) {\n    return [false, type.asPlain.toString()];\n  } else if (type.isDoubleMap) {\n    return [false, type.asDoubleMap.value.toString()];\n  }\n\n  return [false, type.asMap.value.toString()];\n} // we unwrap the type here, turning into an output usable for createType\n\n/** @internal */\n\n\nfunction unwrapStorageType(type, isOptional) {\n  const [hasWrapper, outputType] = getStorageType(type);\n  return isOptional && !hasWrapper ? `Option<${outputType}>` : outputType;\n}\n/** @internal */\n\n\nfunction decodeStorageKey(value) {\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  if (value instanceof StorageKey) {\n    return {\n      key: value,\n      method: value.method,\n      section: value.section\n    };\n  } else if (!value || (0, _util.isString)(value) || (0, _util.isU8a)(value)) {\n    // let Bytes handle these inputs\n    return {\n      key: value\n    };\n  } else if ((0, _util.isFunction)(value)) {\n    return {\n      key: value(),\n      method: value.method,\n      section: value.section\n    };\n  } else if (Array.isArray(value)) {\n    const [fn, ...arg] = value;\n    (0, _util.assert)((0, _util.isFunction)(fn), 'Expected function input for key construction');\n    return {\n      key: fn(...arg),\n      method: fn.method,\n      section: fn.section\n    };\n  }\n\n  throw new Error(`Unable to convert input ${value} to StorageKey`);\n}\n\nfunction decodeHashers(registry, value, hashers) {\n  // the storage entry is xxhashAsU8a(prefix, 128) + xxhashAsU8a(method, 128), 256 bits total\n  let offset = 32;\n  return hashers.reduce((result, [hasher, type]) => {\n    const [hashLen, canDecode] = HASHER_MAP[hasher.type];\n    const decoded = canDecode ? registry.createType(type, value.subarray(offset + hashLen)) : registry.createType('Raw', value.subarray(offset, offset + hashLen));\n    offset += hashLen + (canDecode ? decoded.encodedLength : 0);\n    result.push(decoded);\n    return result;\n  }, []);\n}\n/** @internal */\n\n\nfunction decodeArgsFromMeta(registry, value, meta) {\n  if (!meta || !(meta.type.isDoubleMap || meta.type.isMap)) {\n    return [];\n  }\n\n  if (meta.type.isMap) {\n    const mapInfo = meta.type.asMap;\n    return decodeHashers(registry, value, [[mapInfo.hasher, mapInfo.key.toString()]]);\n  }\n\n  const mapInfo = meta.type.asDoubleMap;\n  return decodeHashers(registry, value, [[mapInfo.hasher, mapInfo.key1.toString()], [mapInfo.key2Hasher, mapInfo.key2.toString()]]);\n}\n/**\n * @name StorageKey\n * @description\n * A representation of a storage key (typically hashed) in the system. It can be\n * constructed by passing in a raw key or a StorageEntry with (optional) arguments.\n */\n\n\nclass StorageKey extends _Bytes.default {\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore This is assigned via this.decodeArgsFromMeta()\n  constructor(registry, value, override = {}) {\n    const {\n      key,\n      method,\n      section\n    } = decodeStorageKey(value);\n    super(registry, key);\n    this._args = void 0;\n    this._meta = void 0;\n    this._outputType = void 0;\n    this._method = void 0;\n    this._section = void 0;\n    this._method = override.method || method;\n    this._section = override.section || section;\n    this._outputType = StorageKey.getType(value); // decode the args (as applicable based on the key and the hashers, after all init)\n\n    this.setMeta(StorageKey.getMeta(value));\n  }\n\n  static getMeta(value) {\n    if (value instanceof StorageKey) {\n      return value.meta;\n    } else if ((0, _util.isFunction)(value)) {\n      return value.meta;\n    } else if (Array.isArray(value)) {\n      const [fn] = value;\n      return fn.meta;\n    }\n\n    return undefined;\n  }\n\n  static getType(value) {\n    if (value instanceof StorageKey) {\n      return value.outputType;\n    } else if ((0, _util.isFunction)(value)) {\n      return unwrapStorageType(value.meta.type);\n    } else if (Array.isArray(value)) {\n      const [fn] = value;\n\n      if (fn.meta) {\n        return unwrapStorageType(fn.meta.type);\n      }\n    } // If we have no type set, default to Raw\n\n\n    return 'Raw';\n  }\n  /**\n   * @description Return the decoded arguments (applicable to map/doublemap with decodable values)\n   */\n\n\n  get args() {\n    return this._args;\n  }\n  /**\n   * @description The metadata or `undefined` when not available\n   */\n\n\n  get meta() {\n    return this._meta;\n  }\n  /**\n   * @description The key method or `undefined` when not specified\n   */\n\n\n  get method() {\n    return this._method;\n  }\n  /**\n   * @description The output type\n   */\n\n\n  get outputType() {\n    return this._outputType;\n  }\n  /**\n   * @description The key section or `undefined` when not specified\n   */\n\n\n  get section() {\n    return this._section;\n  }\n  /**\n   * @description Sets the meta for this key\n   */\n\n\n  setMeta(meta) {\n    this._meta = meta;\n\n    if (meta) {\n      this._outputType = unwrapStorageType(meta.type);\n    }\n\n    try {\n      this._args = decodeArgsFromMeta(this.registry, this.toU8a(true), this.meta);\n    } catch (error) {// ignore...\n    }\n\n    return this;\n  }\n  /**\n   * @description Returns the Human representation for this type\n   */\n\n\n  toHuman() {\n    return this._args.length ? this._args.map(arg => arg.toHuman()) : super.toHuman();\n  }\n  /**\n   * @description Returns the raw type for this\n   */\n\n\n  toRawType() {\n    return 'StorageKey';\n  }\n\n}\n\nexports.default = StorageKey;","map":{"version":3,"sources":["/home/robin/substrate-front-end-template/node_modules/@polkadot/types/primitive/StorageKey.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","unwrapStorageType","default","_util","_Bytes","HASHER_MAP","Blake2_128","Blake2_128Concat","Blake2_256","Identity","Twox128","Twox256","Twox64Concat","getStorageType","type","isPlain","asPlain","toString","isDoubleMap","asDoubleMap","asMap","isOptional","hasWrapper","outputType","decodeStorageKey","StorageKey","key","method","section","isString","isU8a","isFunction","Array","isArray","fn","arg","assert","Error","decodeHashers","registry","hashers","offset","reduce","result","hasher","hashLen","canDecode","decoded","createType","subarray","encodedLength","push","decodeArgsFromMeta","meta","isMap","mapInfo","key1","key2Hasher","key2","constructor","override","_args","_meta","_outputType","_method","_section","getType","setMeta","getMeta","undefined","args","toU8a","error","toHuman","length","map","toRawType"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.unwrapStorageType = unwrapStorageType;\nexports.default = void 0;\n\nvar _util = require(\"@polkadot/util\");\n\nvar _Bytes = _interopRequireDefault(require(\"./Bytes\"));\n\n// Copyright 2017-2020 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nconst HASHER_MAP = {\n  // opaque\n  Blake2_128: [16, false],\n  // eslint-disable-line camelcase\n  Blake2_128Concat: [16, true],\n  // eslint-disable-line camelcase\n  Blake2_256: [32, false],\n  // eslint-disable-line camelcase\n  Identity: [0, true],\n  Twox128: [16, false],\n  Twox256: [32, false],\n  Twox64Concat: [8, true]\n};\n\nfunction getStorageType(type) {\n  if (type.isPlain) {\n    return [false, type.asPlain.toString()];\n  } else if (type.isDoubleMap) {\n    return [false, type.asDoubleMap.value.toString()];\n  }\n\n  return [false, type.asMap.value.toString()];\n} // we unwrap the type here, turning into an output usable for createType\n\n/** @internal */\n\n\nfunction unwrapStorageType(type, isOptional) {\n  const [hasWrapper, outputType] = getStorageType(type);\n  return isOptional && !hasWrapper ? `Option<${outputType}>` : outputType;\n}\n/** @internal */\n\n\nfunction decodeStorageKey(value) {\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  if (value instanceof StorageKey) {\n    return {\n      key: value,\n      method: value.method,\n      section: value.section\n    };\n  } else if (!value || (0, _util.isString)(value) || (0, _util.isU8a)(value)) {\n    // let Bytes handle these inputs\n    return {\n      key: value\n    };\n  } else if ((0, _util.isFunction)(value)) {\n    return {\n      key: value(),\n      method: value.method,\n      section: value.section\n    };\n  } else if (Array.isArray(value)) {\n    const [fn, ...arg] = value;\n    (0, _util.assert)((0, _util.isFunction)(fn), 'Expected function input for key construction');\n    return {\n      key: fn(...arg),\n      method: fn.method,\n      section: fn.section\n    };\n  }\n\n  throw new Error(`Unable to convert input ${value} to StorageKey`);\n}\n\nfunction decodeHashers(registry, value, hashers) {\n  // the storage entry is xxhashAsU8a(prefix, 128) + xxhashAsU8a(method, 128), 256 bits total\n  let offset = 32;\n  return hashers.reduce((result, [hasher, type]) => {\n    const [hashLen, canDecode] = HASHER_MAP[hasher.type];\n    const decoded = canDecode ? registry.createType(type, value.subarray(offset + hashLen)) : registry.createType('Raw', value.subarray(offset, offset + hashLen));\n    offset += hashLen + (canDecode ? decoded.encodedLength : 0);\n    result.push(decoded);\n    return result;\n  }, []);\n}\n/** @internal */\n\n\nfunction decodeArgsFromMeta(registry, value, meta) {\n  if (!meta || !(meta.type.isDoubleMap || meta.type.isMap)) {\n    return [];\n  }\n\n  if (meta.type.isMap) {\n    const mapInfo = meta.type.asMap;\n    return decodeHashers(registry, value, [[mapInfo.hasher, mapInfo.key.toString()]]);\n  }\n\n  const mapInfo = meta.type.asDoubleMap;\n  return decodeHashers(registry, value, [[mapInfo.hasher, mapInfo.key1.toString()], [mapInfo.key2Hasher, mapInfo.key2.toString()]]);\n}\n/**\n * @name StorageKey\n * @description\n * A representation of a storage key (typically hashed) in the system. It can be\n * constructed by passing in a raw key or a StorageEntry with (optional) arguments.\n */\n\n\nclass StorageKey extends _Bytes.default {\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore This is assigned via this.decodeArgsFromMeta()\n  constructor(registry, value, override = {}) {\n    const {\n      key,\n      method,\n      section\n    } = decodeStorageKey(value);\n    super(registry, key);\n    this._args = void 0;\n    this._meta = void 0;\n    this._outputType = void 0;\n    this._method = void 0;\n    this._section = void 0;\n    this._method = override.method || method;\n    this._section = override.section || section;\n    this._outputType = StorageKey.getType(value); // decode the args (as applicable based on the key and the hashers, after all init)\n\n    this.setMeta(StorageKey.getMeta(value));\n  }\n\n  static getMeta(value) {\n    if (value instanceof StorageKey) {\n      return value.meta;\n    } else if ((0, _util.isFunction)(value)) {\n      return value.meta;\n    } else if (Array.isArray(value)) {\n      const [fn] = value;\n      return fn.meta;\n    }\n\n    return undefined;\n  }\n\n  static getType(value) {\n    if (value instanceof StorageKey) {\n      return value.outputType;\n    } else if ((0, _util.isFunction)(value)) {\n      return unwrapStorageType(value.meta.type);\n    } else if (Array.isArray(value)) {\n      const [fn] = value;\n\n      if (fn.meta) {\n        return unwrapStorageType(fn.meta.type);\n      }\n    } // If we have no type set, default to Raw\n\n\n    return 'Raw';\n  }\n  /**\n   * @description Return the decoded arguments (applicable to map/doublemap with decodable values)\n   */\n\n\n  get args() {\n    return this._args;\n  }\n  /**\n   * @description The metadata or `undefined` when not available\n   */\n\n\n  get meta() {\n    return this._meta;\n  }\n  /**\n   * @description The key method or `undefined` when not specified\n   */\n\n\n  get method() {\n    return this._method;\n  }\n  /**\n   * @description The output type\n   */\n\n\n  get outputType() {\n    return this._outputType;\n  }\n  /**\n   * @description The key section or `undefined` when not specified\n   */\n\n\n  get section() {\n    return this._section;\n  }\n  /**\n   * @description Sets the meta for this key\n   */\n\n\n  setMeta(meta) {\n    this._meta = meta;\n\n    if (meta) {\n      this._outputType = unwrapStorageType(meta.type);\n    }\n\n    try {\n      this._args = decodeArgsFromMeta(this.registry, this.toU8a(true), this.meta);\n    } catch (error) {// ignore...\n    }\n\n    return this;\n  }\n  /**\n   * @description Returns the Human representation for this type\n   */\n\n\n  toHuman() {\n    return this._args.length ? this._args.map(arg => arg.toHuman()) : super.toHuman();\n  }\n  /**\n   * @description Returns the raw type for this\n   */\n\n\n  toRawType() {\n    return 'StorageKey';\n  }\n\n}\n\nexports.default = StorageKey;"]},"metadata":{},"sourceType":"script"}