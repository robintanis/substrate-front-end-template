{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = toLatest;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _typesKnown = require(\"@polkadot/types-known\");\n\nvar _util = require(\"@polkadot/util\");\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2.default)(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Since we don't have insight into the origin specification, we can only define what we know about\n// in a pure Substrate/Polkadot implementation, any other custom origins won't be handled at all\n\n\nconst KNOWN_ORIGINS = {\n  Council: 'CollectiveOrigin',\n  System: 'SystemOrigin',\n  TechnicalCommittee: 'CollectiveOrigin'\n}; // TODO Handle consts as well\n\n/**\n * Find and apply the correct type override\n * @internal\n **/\n\nfunction setTypeOverride(sectionTypes, type) {\n  const override = Object.keys(sectionTypes).find(aliased => type.eq(aliased));\n\n  if (override) {\n    type.setOverride(sectionTypes[override]);\n  } else {\n    // FIXME: NOT happy with this approach, but gets over the initial hump cased by (Vec<Announcement>,BalanceOf)\n    const orig = type.toString();\n    const alias = Object.entries(sectionTypes).reduce((result, [from, to]) => [['<', '>'], ['<', ','], [',', '>'], ['(', ')'], ['(', ','], [',', ','], [',', ')']].reduce((result, [one, two]) => result.replace(`${one}${from}${two}`, `${one}${to}${two}`), result), orig);\n\n    if (orig !== alias) {\n      type.setOverride(alias);\n    }\n  }\n}\n/**\n * Apply module-specific type overrides (always be done as part of toLatest)\n * @internal\n **/\n\n\nfunction convertCalls(registry, calls, sectionTypes) {\n  return calls.map(({\n    args,\n    documentation,\n    name\n  }) => {\n    args.forEach(({\n      type\n    }) => setTypeOverride(sectionTypes, type));\n    return registry.createType('FunctionMetadataLatest', {\n      args,\n      documentation,\n      name\n    });\n  });\n}\n/**\n * Apply module-specific type overrides (always be done as part of toLatest)\n * @internal\n **/\n\n\nfunction convertEvents(registry, events, sectionTypes) {\n  return events.map(({\n    args,\n    documentation,\n    name\n  }) => {\n    args.forEach(type => setTypeOverride(sectionTypes, type));\n    return registry.createType('EventMetadataLatest', {\n      args,\n      documentation,\n      name\n    });\n  });\n}\n/**\n * Apply module-specific storage type overrides (always part of toLatest)\n * @internal\n **/\n\n\nfunction convertStorage(registry, {\n  items,\n  prefix\n}, sectionTypes) {\n  return registry.createType('StorageMetadataLatest', {\n    items: items.map(({\n      documentation,\n      fallback,\n      modifier,\n      name,\n      type\n    }) => {\n      let resultType;\n\n      if (type.isMap) {\n        resultType = type.asMap.value;\n      } else if (type.isDoubleMap) {\n        resultType = type.asDoubleMap.value;\n      } else {\n        resultType = type.asPlain;\n      }\n\n      setTypeOverride(sectionTypes, resultType);\n      return registry.createType('StorageEntryMetadataLatest', {\n        documentation,\n        fallback,\n        modifier,\n        name,\n        type\n      });\n    }),\n    prefix\n  });\n} // generate & register the OriginCaller type\n\n\nfunction registerOriginCaller(registry, modules) {\n  const isIndexed = modules.some(({\n    index\n  }) => !index.eqn(255));\n  registry.register({\n    OriginCaller: {\n      _enum: modules.map((mod, index) => [mod.name.toString(), isIndexed ? mod.index.toNumber() : index]).sort((a, b) => a[1] - b[1]).reduce((result, [name, index]) => {\n        for (let i = Object.keys(result).length; i < index; i++) {\n          result[`Empty${i}`] = 'Null';\n        }\n\n        result[name] = KNOWN_ORIGINS[name] || 'Null';\n        return result;\n      }, {})\n    }\n  });\n}\n/**\n * Convert the Metadata (which is an alias) to latest - effectively this _always_ get applied to the top-level &\n * most-recent metadata, since it allows us a chance to actually apply call and storage specific type aliasses\n * @internal\n **/\n\n\nfunction toLatest(registry, {\n  extrinsic,\n  modules\n}) {\n  registerOriginCaller(registry, modules);\n  return registry.createType('MetadataLatest', {\n    extrinsic,\n    modules: modules.map(mod => {\n      const calls = mod.calls.unwrapOr(null);\n      const events = mod.events.unwrapOr(null);\n      const storage = mod.storage.unwrapOr(null);\n      const sectionTypes = (0, _typesKnown.getModuleTypes)(registry, (0, _util.stringCamelCase)(mod.name.toString()));\n      return registry.createType('ModuleMetadataLatest', _objectSpread(_objectSpread({}, mod), {}, {\n        calls: calls ? convertCalls(registry, calls, sectionTypes) : null,\n        events: events ? convertEvents(registry, events, sectionTypes) : null,\n        storage: storage ? convertStorage(registry, storage, sectionTypes) : null\n      }));\n    })\n  });\n}","map":{"version":3,"sources":["/home/robin/substrate-front-end-template/node_modules/@polkadot/metadata/Metadata/v12/toLatest.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","default","toLatest","_defineProperty2","_typesKnown","_util","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","KNOWN_ORIGINS","Council","System","TechnicalCommittee","setTypeOverride","sectionTypes","type","override","find","aliased","eq","setOverride","orig","toString","alias","entries","reduce","result","from","to","one","two","replace","convertCalls","registry","calls","map","args","documentation","name","createType","convertEvents","events","convertStorage","items","prefix","fallback","modifier","resultType","isMap","asMap","isDoubleMap","asDoubleMap","asPlain","registerOriginCaller","modules","isIndexed","some","index","eqn","register","OriginCaller","_enum","mod","toNumber","sort","a","b","extrinsic","unwrapOr","storage","getModuleTypes","stringCamelCase"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = toLatest;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _typesKnown = require(\"@polkadot/types-known\");\n\nvar _util = require(\"@polkadot/util\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n// Since we don't have insight into the origin specification, we can only define what we know about\n// in a pure Substrate/Polkadot implementation, any other custom origins won't be handled at all\nconst KNOWN_ORIGINS = {\n  Council: 'CollectiveOrigin',\n  System: 'SystemOrigin',\n  TechnicalCommittee: 'CollectiveOrigin'\n}; // TODO Handle consts as well\n\n/**\n * Find and apply the correct type override\n * @internal\n **/\n\nfunction setTypeOverride(sectionTypes, type) {\n  const override = Object.keys(sectionTypes).find(aliased => type.eq(aliased));\n\n  if (override) {\n    type.setOverride(sectionTypes[override]);\n  } else {\n    // FIXME: NOT happy with this approach, but gets over the initial hump cased by (Vec<Announcement>,BalanceOf)\n    const orig = type.toString();\n    const alias = Object.entries(sectionTypes).reduce((result, [from, to]) => [['<', '>'], ['<', ','], [',', '>'], ['(', ')'], ['(', ','], [',', ','], [',', ')']].reduce((result, [one, two]) => result.replace(`${one}${from}${two}`, `${one}${to}${two}`), result), orig);\n\n    if (orig !== alias) {\n      type.setOverride(alias);\n    }\n  }\n}\n/**\n * Apply module-specific type overrides (always be done as part of toLatest)\n * @internal\n **/\n\n\nfunction convertCalls(registry, calls, sectionTypes) {\n  return calls.map(({\n    args,\n    documentation,\n    name\n  }) => {\n    args.forEach(({\n      type\n    }) => setTypeOverride(sectionTypes, type));\n    return registry.createType('FunctionMetadataLatest', {\n      args,\n      documentation,\n      name\n    });\n  });\n}\n/**\n * Apply module-specific type overrides (always be done as part of toLatest)\n * @internal\n **/\n\n\nfunction convertEvents(registry, events, sectionTypes) {\n  return events.map(({\n    args,\n    documentation,\n    name\n  }) => {\n    args.forEach(type => setTypeOverride(sectionTypes, type));\n    return registry.createType('EventMetadataLatest', {\n      args,\n      documentation,\n      name\n    });\n  });\n}\n/**\n * Apply module-specific storage type overrides (always part of toLatest)\n * @internal\n **/\n\n\nfunction convertStorage(registry, {\n  items,\n  prefix\n}, sectionTypes) {\n  return registry.createType('StorageMetadataLatest', {\n    items: items.map(({\n      documentation,\n      fallback,\n      modifier,\n      name,\n      type\n    }) => {\n      let resultType;\n\n      if (type.isMap) {\n        resultType = type.asMap.value;\n      } else if (type.isDoubleMap) {\n        resultType = type.asDoubleMap.value;\n      } else {\n        resultType = type.asPlain;\n      }\n\n      setTypeOverride(sectionTypes, resultType);\n      return registry.createType('StorageEntryMetadataLatest', {\n        documentation,\n        fallback,\n        modifier,\n        name,\n        type\n      });\n    }),\n    prefix\n  });\n} // generate & register the OriginCaller type\n\n\nfunction registerOriginCaller(registry, modules) {\n  const isIndexed = modules.some(({\n    index\n  }) => !index.eqn(255));\n  registry.register({\n    OriginCaller: {\n      _enum: modules.map((mod, index) => [mod.name.toString(), isIndexed ? mod.index.toNumber() : index]).sort((a, b) => a[1] - b[1]).reduce((result, [name, index]) => {\n        for (let i = Object.keys(result).length; i < index; i++) {\n          result[`Empty${i}`] = 'Null';\n        }\n\n        result[name] = KNOWN_ORIGINS[name] || 'Null';\n        return result;\n      }, {})\n    }\n  });\n}\n/**\n * Convert the Metadata (which is an alias) to latest - effectively this _always_ get applied to the top-level &\n * most-recent metadata, since it allows us a chance to actually apply call and storage specific type aliasses\n * @internal\n **/\n\n\nfunction toLatest(registry, {\n  extrinsic,\n  modules\n}) {\n  registerOriginCaller(registry, modules);\n  return registry.createType('MetadataLatest', {\n    extrinsic,\n    modules: modules.map(mod => {\n      const calls = mod.calls.unwrapOr(null);\n      const events = mod.events.unwrapOr(null);\n      const storage = mod.storage.unwrapOr(null);\n      const sectionTypes = (0, _typesKnown.getModuleTypes)(registry, (0, _util.stringCamelCase)(mod.name.toString()));\n      return registry.createType('ModuleMetadataLatest', _objectSpread(_objectSpread({}, mod), {}, {\n        calls: calls ? convertCalls(registry, calls, sectionTypes) : null,\n        events: events ? convertEvents(registry, events, sectionTypes) : null,\n        storage: storage ? convertStorage(registry, storage, sectionTypes) : null\n      }));\n    })\n  });\n}"]},"metadata":{},"sourceType":"script"}