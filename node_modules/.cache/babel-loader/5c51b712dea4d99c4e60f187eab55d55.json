{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = decode;\n\nvar _util = require(\"@polkadot/util\");\n\nvar _utilCrypto = require(\"@polkadot/util-crypto\");\n\nvar _defaults = require(\"./defaults\"); // Copyright 2017-2020 @polkadot/keyring authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nconst SEED_OFFSET = _defaults.PKCS8_HEADER.length;\n\nfunction decodePkcs8(encoded) {\n  const header = encoded.subarray(0, _defaults.PKCS8_HEADER.length);\n  (0, _util.assert)(header.toString() === _defaults.PKCS8_HEADER.toString(), 'Invalid Pkcs8 header found in body');\n  let secretKey = encoded.subarray(SEED_OFFSET, SEED_OFFSET + _defaults.SEC_LENGTH);\n  let divOffset = SEED_OFFSET + _defaults.SEC_LENGTH;\n  let divider = encoded.subarray(divOffset, divOffset + _defaults.PKCS8_DIVIDER.length); // old-style, we have the seed here\n\n  if (divider.toString() !== _defaults.PKCS8_DIVIDER.toString()) {\n    divOffset = SEED_OFFSET + _defaults.SEED_LENGTH;\n    secretKey = encoded.subarray(SEED_OFFSET, divOffset);\n    divider = encoded.subarray(divOffset, divOffset + _defaults.PKCS8_DIVIDER.length);\n  }\n\n  (0, _util.assert)(divider.toString() === _defaults.PKCS8_DIVIDER.toString(), 'Invalid Pkcs8 divider found in body');\n  const pubOffset = divOffset + _defaults.PKCS8_DIVIDER.length;\n  const publicKey = encoded.subarray(pubOffset, pubOffset + _defaults.PUB_LENGTH);\n  return {\n    publicKey,\n    secretKey\n  };\n}\n\nfunction decode(passphrase, encrypted, encType = _defaults.ENCODING) {\n  (0, _util.assert)(encrypted, 'No encrypted data available to decode');\n  (0, _util.assert)(passphrase || !encType.includes('xsalsa20-poly1305'), 'Password required to decode encypted data');\n  let encoded = encrypted;\n\n  if (passphrase) {\n    let password;\n\n    if (encType.includes('scrypt')) {\n      const {\n        params,\n        salt\n      } = (0, _utilCrypto.scryptFromU8a)(encrypted);\n      password = (0, _utilCrypto.scryptEncode)(passphrase, salt, params).password;\n      encrypted = encrypted.subarray(_defaults.SCRYPT_LENGTH);\n    } else {\n      password = (0, _util.stringToU8a)(passphrase);\n    }\n\n    encoded = (0, _utilCrypto.naclDecrypt)(encrypted.subarray(_defaults.NONCE_LENGTH), encrypted.subarray(0, _defaults.NONCE_LENGTH), (0, _util.u8aFixLength)(password, 256, true));\n  }\n\n  (0, _util.assert)(encoded, 'Unable to decode using the supplied passphrase');\n  return decodePkcs8(encoded);\n}","map":{"version":3,"sources":["/home/robin/substrate-front-end-template/node_modules/@polkadot/keyring/pair/decode.js"],"names":["Object","defineProperty","exports","value","default","decode","_util","require","_utilCrypto","_defaults","SEED_OFFSET","PKCS8_HEADER","length","decodePkcs8","encoded","header","subarray","assert","toString","secretKey","SEC_LENGTH","divOffset","divider","PKCS8_DIVIDER","SEED_LENGTH","pubOffset","publicKey","PUB_LENGTH","passphrase","encrypted","encType","ENCODING","includes","password","params","salt","scryptFromU8a","scryptEncode","SCRYPT_LENGTH","stringToU8a","naclDecrypt","NONCE_LENGTH","u8aFixLength"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = decode;\n\nvar _util = require(\"@polkadot/util\");\n\nvar _utilCrypto = require(\"@polkadot/util-crypto\");\n\nvar _defaults = require(\"./defaults\");\n\n// Copyright 2017-2020 @polkadot/keyring authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nconst SEED_OFFSET = _defaults.PKCS8_HEADER.length;\n\nfunction decodePkcs8(encoded) {\n  const header = encoded.subarray(0, _defaults.PKCS8_HEADER.length);\n  (0, _util.assert)(header.toString() === _defaults.PKCS8_HEADER.toString(), 'Invalid Pkcs8 header found in body');\n  let secretKey = encoded.subarray(SEED_OFFSET, SEED_OFFSET + _defaults.SEC_LENGTH);\n  let divOffset = SEED_OFFSET + _defaults.SEC_LENGTH;\n  let divider = encoded.subarray(divOffset, divOffset + _defaults.PKCS8_DIVIDER.length); // old-style, we have the seed here\n\n  if (divider.toString() !== _defaults.PKCS8_DIVIDER.toString()) {\n    divOffset = SEED_OFFSET + _defaults.SEED_LENGTH;\n    secretKey = encoded.subarray(SEED_OFFSET, divOffset);\n    divider = encoded.subarray(divOffset, divOffset + _defaults.PKCS8_DIVIDER.length);\n  }\n\n  (0, _util.assert)(divider.toString() === _defaults.PKCS8_DIVIDER.toString(), 'Invalid Pkcs8 divider found in body');\n  const pubOffset = divOffset + _defaults.PKCS8_DIVIDER.length;\n  const publicKey = encoded.subarray(pubOffset, pubOffset + _defaults.PUB_LENGTH);\n  return {\n    publicKey,\n    secretKey\n  };\n}\n\nfunction decode(passphrase, encrypted, encType = _defaults.ENCODING) {\n  (0, _util.assert)(encrypted, 'No encrypted data available to decode');\n  (0, _util.assert)(passphrase || !encType.includes('xsalsa20-poly1305'), 'Password required to decode encypted data');\n  let encoded = encrypted;\n\n  if (passphrase) {\n    let password;\n\n    if (encType.includes('scrypt')) {\n      const {\n        params,\n        salt\n      } = (0, _utilCrypto.scryptFromU8a)(encrypted);\n      password = (0, _utilCrypto.scryptEncode)(passphrase, salt, params).password;\n      encrypted = encrypted.subarray(_defaults.SCRYPT_LENGTH);\n    } else {\n      password = (0, _util.stringToU8a)(passphrase);\n    }\n\n    encoded = (0, _utilCrypto.naclDecrypt)(encrypted.subarray(_defaults.NONCE_LENGTH), encrypted.subarray(0, _defaults.NONCE_LENGTH), (0, _util.u8aFixLength)(password, 256, true));\n  }\n\n  (0, _util.assert)(encoded, 'Unable to decode using the supplied passphrase');\n  return decodePkcs8(encoded);\n}"]},"metadata":{},"sourceType":"script"}