{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.typeSplit = typeSplit;\n\nvar _util = require(\"@polkadot/util\"); // Copyright 2017-2020 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nfunction isNotNested(...counters) {\n  return !counters.some(counter => counter !== 0);\n} // safely split a string on ', ' while taking care of any nested occurences\n\n\nfunction typeSplit(type) {\n  let [cDepth, fDepth, sDepth, tDepth, start] = [0, 0, 0, 0, 0];\n  const result = [];\n\n  const extract = index => {\n    if (isNotNested(cDepth, fDepth, sDepth, tDepth)) {\n      result.push(type.substr(start, index - start).trim());\n      start = index + 1;\n    }\n  };\n\n  for (let index = 0; index < type.length; index++) {\n    switch (type[index]) {\n      // if we are not nested, add the type\n      case ',':\n        extract(index);\n        break;\n      // adjust compact/vec (and friends) depth\n\n      case '<':\n        cDepth++;\n        break;\n\n      case '>':\n        cDepth--;\n        break;\n      // adjust fixed vec depths\n\n      case '[':\n        fDepth++;\n        break;\n\n      case ']':\n        fDepth--;\n        break;\n      // adjust struct depth\n\n      case '{':\n        sDepth++;\n        break;\n\n      case '}':\n        sDepth--;\n        break;\n      // adjust tuple depth\n\n      case '(':\n        tDepth++;\n        break;\n\n      case ')':\n        tDepth--;\n        break;\n    }\n  }\n\n  (0, _util.assert)(isNotNested(cDepth, fDepth, sDepth, tDepth), `Invalid defintion (missing terminators) found in ${type}`); // the final leg of the journey\n\n  result.push(type.substr(start, type.length - start).trim());\n  return result;\n}","map":{"version":3,"sources":["/home/robin/substrate-front-end-template/node_modules/@polkadot/types/create/typeSplit.js"],"names":["Object","defineProperty","exports","value","typeSplit","_util","require","isNotNested","counters","some","counter","type","cDepth","fDepth","sDepth","tDepth","start","result","extract","index","push","substr","trim","length","assert"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,SAAR,GAAoBA,SAApB;;AAEA,IAAIC,KAAK,GAAGC,OAAO,CAAC,gBAAD,CAAnB,C,CAEA;AACA;;;AACA,SAASC,WAAT,CAAqB,GAAGC,QAAxB,EAAkC;AAChC,SAAO,CAACA,QAAQ,CAACC,IAAT,CAAcC,OAAO,IAAIA,OAAO,KAAK,CAArC,CAAR;AACD,C,CAAC;;;AAGF,SAASN,SAAT,CAAmBO,IAAnB,EAAyB;AACvB,MAAI,CAACC,MAAD,EAASC,MAAT,EAAiBC,MAAjB,EAAyBC,MAAzB,EAAiCC,KAAjC,IAA0C,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,CAA9C;AACA,QAAMC,MAAM,GAAG,EAAf;;AAEA,QAAMC,OAAO,GAAGC,KAAK,IAAI;AACvB,QAAIZ,WAAW,CAACK,MAAD,EAASC,MAAT,EAAiBC,MAAjB,EAAyBC,MAAzB,CAAf,EAAiD;AAC/CE,MAAAA,MAAM,CAACG,IAAP,CAAYT,IAAI,CAACU,MAAL,CAAYL,KAAZ,EAAmBG,KAAK,GAAGH,KAA3B,EAAkCM,IAAlC,EAAZ;AACAN,MAAAA,KAAK,GAAGG,KAAK,GAAG,CAAhB;AACD;AACF,GALD;;AAOA,OAAK,IAAIA,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAGR,IAAI,CAACY,MAAjC,EAAyCJ,KAAK,EAA9C,EAAkD;AAChD,YAAQR,IAAI,CAACQ,KAAD,CAAZ;AACE;AACA,WAAK,GAAL;AACED,QAAAA,OAAO,CAACC,KAAD,CAAP;AACA;AACF;;AAEA,WAAK,GAAL;AACEP,QAAAA,MAAM;AACN;;AAEF,WAAK,GAAL;AACEA,QAAAA,MAAM;AACN;AACF;;AAEA,WAAK,GAAL;AACEC,QAAAA,MAAM;AACN;;AAEF,WAAK,GAAL;AACEA,QAAAA,MAAM;AACN;AACF;;AAEA,WAAK,GAAL;AACEC,QAAAA,MAAM;AACN;;AAEF,WAAK,GAAL;AACEA,QAAAA,MAAM;AACN;AACF;;AAEA,WAAK,GAAL;AACEC,QAAAA,MAAM;AACN;;AAEF,WAAK,GAAL;AACEA,QAAAA,MAAM;AACN;AAxCJ;AA0CD;;AAED,GAAC,GAAGV,KAAK,CAACmB,MAAV,EAAkBjB,WAAW,CAACK,MAAD,EAASC,MAAT,EAAiBC,MAAjB,EAAyBC,MAAzB,CAA7B,EAAgE,oDAAmDJ,IAAK,EAAxH,EAxDuB,CAwDqG;;AAE5HM,EAAAA,MAAM,CAACG,IAAP,CAAYT,IAAI,CAACU,MAAL,CAAYL,KAAZ,EAAmBL,IAAI,CAACY,MAAL,GAAcP,KAAjC,EAAwCM,IAAxC,EAAZ;AACA,SAAOL,MAAP;AACD","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.typeSplit = typeSplit;\n\nvar _util = require(\"@polkadot/util\");\n\n// Copyright 2017-2020 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nfunction isNotNested(...counters) {\n  return !counters.some(counter => counter !== 0);\n} // safely split a string on ', ' while taking care of any nested occurences\n\n\nfunction typeSplit(type) {\n  let [cDepth, fDepth, sDepth, tDepth, start] = [0, 0, 0, 0, 0];\n  const result = [];\n\n  const extract = index => {\n    if (isNotNested(cDepth, fDepth, sDepth, tDepth)) {\n      result.push(type.substr(start, index - start).trim());\n      start = index + 1;\n    }\n  };\n\n  for (let index = 0; index < type.length; index++) {\n    switch (type[index]) {\n      // if we are not nested, add the type\n      case ',':\n        extract(index);\n        break;\n      // adjust compact/vec (and friends) depth\n\n      case '<':\n        cDepth++;\n        break;\n\n      case '>':\n        cDepth--;\n        break;\n      // adjust fixed vec depths\n\n      case '[':\n        fDepth++;\n        break;\n\n      case ']':\n        fDepth--;\n        break;\n      // adjust struct depth\n\n      case '{':\n        sDepth++;\n        break;\n\n      case '}':\n        sDepth--;\n        break;\n      // adjust tuple depth\n\n      case '(':\n        tDepth++;\n        break;\n\n      case ')':\n        tDepth--;\n        break;\n    }\n  }\n\n  (0, _util.assert)(isNotNested(cDepth, fDepth, sDepth, tDepth), `Invalid defintion (missing terminators) found in ${type}`); // the final leg of the journey\n\n  result.push(type.substr(start, type.length - start).trim());\n  return result;\n}"]},"metadata":{},"sourceType":"script"}