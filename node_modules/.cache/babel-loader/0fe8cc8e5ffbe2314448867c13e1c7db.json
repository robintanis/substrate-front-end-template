{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getTypeDef = getTypeDef;\n\nvar _types = require(\"./types\");\n\nvar _util = require(\"@polkadot/util\");\n\nvar _sanitize = _interopRequireDefault(require(\"./sanitize\"));\n\nvar _typeSplit = require(\"./typeSplit\"); // Copyright 2017-2020 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nconst MAX_NESTED = 64; // decode an enum of either of the following forms\n//  { _enum: ['A', 'B', 'C'] }\n//  { _enum: { A: AccountId, B: Balance, C: u32 } }\n\nfunction _decodeEnum(value, details, count) {\n  value.info = _types.TypeDefInfo.Enum; // not as pretty, but remain compatible with oo7 for both struct and Array types\n\n  value.sub = Array.isArray(details) ? details.map(name => ({\n    info: _types.TypeDefInfo.Plain,\n    name,\n    type: 'Null'\n  })) : Object.entries(details).map(([name, type]) => // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  getTypeDef(type || 'Null', {\n    name\n  }, count));\n  return value;\n} // decode a set of the form\n//   { _set: { A: 0b0001, B: 0b0010, C: 0b0100 } }\n\n\nfunction _decodeSet(value, details) {\n  value.info = _types.TypeDefInfo.Set;\n  value.length = details._bitLength;\n  value.sub = Object.entries(details).filter(([name]) => !name.startsWith('_')).map(([name, index]) => ({\n    index,\n    info: _types.TypeDefInfo.Plain,\n    name,\n    type: name\n  }));\n  return value;\n} // decode a struct, set or enum\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\nfunction _decodeStruct(value, type, _, count) {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n  const parsed = JSON.parse(type);\n  const keys = Object.keys(parsed);\n\n  if (keys.length === 1 && keys[0] === '_enum') {\n    return _decodeEnum(value, parsed[keys[0]], count);\n  } else if (keys.length === 1 && keys[0] === '_set') {\n    return _decodeSet(value, parsed[keys[0]]);\n  }\n\n  value.alias = parsed._alias ? new Map(Object.entries(parsed._alias)) : undefined;\n  value.sub = keys.filter(name => !['_alias'].includes(name)).map(name => // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  getTypeDef(parsed[name], {\n    name\n  }, count));\n  return value;\n} // decode a fixed vector, e.g. [u8;32]\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\nfunction _decodeFixedVec(value, type, _, count) {\n  const [vecType, strLength, displayName] = type.substr(1, type.length - 2).split(';');\n  const length = parseInt(strLength.trim(), 10); // as a first round, only u8 via u8aFixed, we can add more support\n\n  (0, _util.assert)(length <= 256, `${type}: Only support for [Type; <length>], where length <= 256`);\n  value.displayName = displayName;\n  value.length = length; // eslint-disable-next-line @typescript-eslint/no-use-before-define\n\n  value.sub = getTypeDef(vecType, {}, count);\n  return value;\n} // decode a tuple\n\n\nfunction _decodeTuple(value, _, subType, count) {\n  value.sub = subType.length === 0 ? [] : (0, _typeSplit.typeSplit)(subType).map(inner => // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  getTypeDef(inner, {}, count));\n  return value;\n} // decode a Int/UInt<bitLength[, name]>\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\nfunction _decodeAnyInt(value, type, _, clazz) {\n  const [strLength, displayName] = type.substr(clazz.length + 1, type.length - clazz.length - 1 - 1).split(',');\n  const length = parseInt(strLength.trim(), 10); // as a first round, only u8 via u8aFixed, we can add more support\n\n  (0, _util.assert)(length <= 8192 && length % 8 === 0, `${type}: Only support for ${clazz}<bitLength>, where length <= 8192 and a power of 8, found ${length}`);\n  value.displayName = displayName;\n  value.length = length;\n  return value;\n}\n\nfunction _decodeInt(value, type, subType) {\n  return _decodeAnyInt(value, type, subType, 'Int');\n}\n\nfunction _decodeUInt(value, type, subType) {\n  return _decodeAnyInt(value, type, subType, 'UInt');\n} // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\nfunction _decodeDoNotConstruct(value, type, _) {\n  const NAME_LENGTH = 'DoNotConstruct'.length;\n  value.displayName = type.substr(NAME_LENGTH + 1, type.length - NAME_LENGTH - 1 - 1);\n  return value;\n}\n\nfunction hasWrapper(type, [start, end]) {\n  if (type.substr(0, start.length) !== start) {\n    return false;\n  }\n\n  (0, _util.assert)(type.endsWith(end), `Expected '${start}' closing with '${end}' on ${type}`);\n  return true;\n}\n\nconst nestedExtraction = [['[', ']', _types.TypeDefInfo.VecFixed, _decodeFixedVec], ['{', '}', _types.TypeDefInfo.Struct, _decodeStruct], ['(', ')', _types.TypeDefInfo.Tuple, _decodeTuple], // the inner for these are the same as tuple, multiple values\n['BTreeMap<', '>', _types.TypeDefInfo.BTreeMap, _decodeTuple], ['HashMap<', '>', _types.TypeDefInfo.HashMap, _decodeTuple], ['Int<', '>', _types.TypeDefInfo.Int, _decodeInt], ['Result<', '>', _types.TypeDefInfo.Result, _decodeTuple], ['UInt<', '>', _types.TypeDefInfo.UInt, _decodeUInt], ['DoNotConstruct<', '>', _types.TypeDefInfo.DoNotConstruct, _decodeDoNotConstruct]];\nconst wrappedExtraction = [['BTreeSet<', '>', _types.TypeDefInfo.BTreeSet], ['Compact<', '>', _types.TypeDefInfo.Compact], ['Linkage<', '>', _types.TypeDefInfo.Linkage], ['Option<', '>', _types.TypeDefInfo.Option], ['Vec<', '>', _types.TypeDefInfo.Vec]];\n\nfunction extractSubType(type, [start, end]) {\n  return type.substr(start.length, type.length - start.length - end.length);\n}\n\nfunction getTypeDef(_type, {\n  displayName,\n  name\n} = {}, count = 0) {\n  // create the type via Type, allowing types to be sanitized\n  const type = (0, _sanitize.default)(_type);\n  const value = {\n    displayName,\n    info: _types.TypeDefInfo.Plain,\n    name,\n    type\n  };\n\n  if (++count === MAX_NESTED) {\n    console.warn('getTypeDef: Maximum nested limit reached');\n    return value;\n  }\n\n  const nested = nestedExtraction.find(nested => hasWrapper(type, nested));\n\n  if (nested) {\n    value.info = nested[2];\n    return nested[3](value, type, extractSubType(type, nested), count);\n  }\n\n  const wrapped = wrappedExtraction.find(wrapped => hasWrapper(type, wrapped));\n\n  if (wrapped) {\n    value.info = wrapped[2];\n    value.sub = getTypeDef(extractSubType(type, wrapped), {}, count);\n  }\n\n  return value;\n}","map":{"version":3,"sources":["/home/robin/substrate-front-end-template/node_modules/@polkadot/types/create/getTypeDef.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","getTypeDef","_types","_util","_sanitize","_typeSplit","MAX_NESTED","_decodeEnum","details","count","info","TypeDefInfo","Enum","sub","Array","isArray","map","name","Plain","type","entries","_decodeSet","Set","length","_bitLength","filter","startsWith","index","_decodeStruct","_","parsed","JSON","parse","keys","alias","_alias","Map","undefined","includes","_decodeFixedVec","vecType","strLength","displayName","substr","split","parseInt","trim","assert","_decodeTuple","subType","typeSplit","inner","_decodeAnyInt","clazz","_decodeInt","_decodeUInt","_decodeDoNotConstruct","NAME_LENGTH","hasWrapper","start","end","endsWith","nestedExtraction","VecFixed","Struct","Tuple","BTreeMap","HashMap","Int","Result","UInt","DoNotConstruct","wrappedExtraction","BTreeSet","Compact","Linkage","Option","Vec","extractSubType","_type","default","console","warn","nested","find","wrapped"],"mappings":"AAAA;;AAEA,IAAIA,sBAAsB,GAAGC,OAAO,CAAC,8CAAD,CAApC;;AAEAC,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,UAAR,GAAqBA,UAArB;;AAEA,IAAIC,MAAM,GAAGN,OAAO,CAAC,SAAD,CAApB;;AAEA,IAAIO,KAAK,GAAGP,OAAO,CAAC,gBAAD,CAAnB;;AAEA,IAAIQ,SAAS,GAAGT,sBAAsB,CAACC,OAAO,CAAC,YAAD,CAAR,CAAtC;;AAEA,IAAIS,UAAU,GAAGT,OAAO,CAAC,aAAD,CAAxB,C,CAEA;AACA;;;AACA,MAAMU,UAAU,GAAG,EAAnB,C,CAAuB;AACvB;AACA;;AAEA,SAASC,WAAT,CAAqBP,KAArB,EAA4BQ,OAA5B,EAAqCC,KAArC,EAA4C;AAC1CT,EAAAA,KAAK,CAACU,IAAN,GAAaR,MAAM,CAACS,WAAP,CAAmBC,IAAhC,CAD0C,CACJ;;AAEtCZ,EAAAA,KAAK,CAACa,GAAN,GAAYC,KAAK,CAACC,OAAN,CAAcP,OAAd,IAAyBA,OAAO,CAACQ,GAAR,CAAYC,IAAI,KAAK;AACxDP,IAAAA,IAAI,EAAER,MAAM,CAACS,WAAP,CAAmBO,KAD+B;AAExDD,IAAAA,IAFwD;AAGxDE,IAAAA,IAAI,EAAE;AAHkD,GAAL,CAAhB,CAAzB,GAINtB,MAAM,CAACuB,OAAP,CAAeZ,OAAf,EAAwBQ,GAAxB,CAA4B,CAAC,CAACC,IAAD,EAAOE,IAAP,CAAD,KAAkB;AACpDlB,EAAAA,UAAU,CAACkB,IAAI,IAAI,MAAT,EAAiB;AACzBF,IAAAA;AADyB,GAAjB,EAEPR,KAFO,CADJ,CAJN;AAQA,SAAOT,KAAP;AACD,C,CAAC;AACF;;;AAGA,SAASqB,UAAT,CAAoBrB,KAApB,EAA2BQ,OAA3B,EAAoC;AAClCR,EAAAA,KAAK,CAACU,IAAN,GAAaR,MAAM,CAACS,WAAP,CAAmBW,GAAhC;AACAtB,EAAAA,KAAK,CAACuB,MAAN,GAAef,OAAO,CAACgB,UAAvB;AACAxB,EAAAA,KAAK,CAACa,GAAN,GAAYhB,MAAM,CAACuB,OAAP,CAAeZ,OAAf,EAAwBiB,MAAxB,CAA+B,CAAC,CAACR,IAAD,CAAD,KAAY,CAACA,IAAI,CAACS,UAAL,CAAgB,GAAhB,CAA5C,EAAkEV,GAAlE,CAAsE,CAAC,CAACC,IAAD,EAAOU,KAAP,CAAD,MAAoB;AACpGA,IAAAA,KADoG;AAEpGjB,IAAAA,IAAI,EAAER,MAAM,CAACS,WAAP,CAAmBO,KAF2E;AAGpGD,IAAAA,IAHoG;AAIpGE,IAAAA,IAAI,EAAEF;AAJ8F,GAApB,CAAtE,CAAZ;AAMA,SAAOjB,KAAP;AACD,C,CAAC;AACF;;;AAGA,SAAS4B,aAAT,CAAuB5B,KAAvB,EAA8BmB,IAA9B,EAAoCU,CAApC,EAAuCpB,KAAvC,EAA8C;AAC5C;AACA,QAAMqB,MAAM,GAAGC,IAAI,CAACC,KAAL,CAAWb,IAAX,CAAf;AACA,QAAMc,IAAI,GAAGpC,MAAM,CAACoC,IAAP,CAAYH,MAAZ,CAAb;;AAEA,MAAIG,IAAI,CAACV,MAAL,KAAgB,CAAhB,IAAqBU,IAAI,CAAC,CAAD,CAAJ,KAAY,OAArC,EAA8C;AAC5C,WAAO1B,WAAW,CAACP,KAAD,EAAQ8B,MAAM,CAACG,IAAI,CAAC,CAAD,CAAL,CAAd,EAAyBxB,KAAzB,CAAlB;AACD,GAFD,MAEO,IAAIwB,IAAI,CAACV,MAAL,KAAgB,CAAhB,IAAqBU,IAAI,CAAC,CAAD,CAAJ,KAAY,MAArC,EAA6C;AAClD,WAAOZ,UAAU,CAACrB,KAAD,EAAQ8B,MAAM,CAACG,IAAI,CAAC,CAAD,CAAL,CAAd,CAAjB;AACD;;AAEDjC,EAAAA,KAAK,CAACkC,KAAN,GAAcJ,MAAM,CAACK,MAAP,GAAgB,IAAIC,GAAJ,CAAQvC,MAAM,CAACuB,OAAP,CAAeU,MAAM,CAACK,MAAtB,CAAR,CAAhB,GAAyDE,SAAvE;AACArC,EAAAA,KAAK,CAACa,GAAN,GAAYoB,IAAI,CAACR,MAAL,CAAYR,IAAI,IAAI,CAAC,CAAC,QAAD,EAAWqB,QAAX,CAAoBrB,IAApB,CAArB,EAAgDD,GAAhD,CAAoDC,IAAI,IAAI;AACxEhB,EAAAA,UAAU,CAAC6B,MAAM,CAACb,IAAD,CAAP,EAAe;AACvBA,IAAAA;AADuB,GAAf,EAEPR,KAFO,CADE,CAAZ;AAIA,SAAOT,KAAP;AACD,C,CAAC;AACF;;;AAGA,SAASuC,eAAT,CAAyBvC,KAAzB,EAAgCmB,IAAhC,EAAsCU,CAAtC,EAAyCpB,KAAzC,EAAgD;AAC9C,QAAM,CAAC+B,OAAD,EAAUC,SAAV,EAAqBC,WAArB,IAAoCvB,IAAI,CAACwB,MAAL,CAAY,CAAZ,EAAexB,IAAI,CAACI,MAAL,GAAc,CAA7B,EAAgCqB,KAAhC,CAAsC,GAAtC,CAA1C;AACA,QAAMrB,MAAM,GAAGsB,QAAQ,CAACJ,SAAS,CAACK,IAAV,EAAD,EAAmB,EAAnB,CAAvB,CAF8C,CAEC;;AAE/C,GAAC,GAAG3C,KAAK,CAAC4C,MAAV,EAAkBxB,MAAM,IAAI,GAA5B,EAAkC,GAAEJ,IAAK,0DAAzC;AACAnB,EAAAA,KAAK,CAAC0C,WAAN,GAAoBA,WAApB;AACA1C,EAAAA,KAAK,CAACuB,MAAN,GAAeA,MAAf,CAN8C,CAMvB;;AAEvBvB,EAAAA,KAAK,CAACa,GAAN,GAAYZ,UAAU,CAACuC,OAAD,EAAU,EAAV,EAAc/B,KAAd,CAAtB;AACA,SAAOT,KAAP;AACD,C,CAAC;;;AAGF,SAASgD,YAAT,CAAsBhD,KAAtB,EAA6B6B,CAA7B,EAAgCoB,OAAhC,EAAyCxC,KAAzC,EAAgD;AAC9CT,EAAAA,KAAK,CAACa,GAAN,GAAYoC,OAAO,CAAC1B,MAAR,KAAmB,CAAnB,GAAuB,EAAvB,GAA4B,CAAC,GAAGlB,UAAU,CAAC6C,SAAf,EAA0BD,OAA1B,EAAmCjC,GAAnC,CAAuCmC,KAAK,IAAI;AACxFlD,EAAAA,UAAU,CAACkD,KAAD,EAAQ,EAAR,EAAY1C,KAAZ,CAD8B,CAAxC;AAEA,SAAOT,KAAP;AACD,C,CAAC;AACF;;;AAGA,SAASoD,aAAT,CAAuBpD,KAAvB,EAA8BmB,IAA9B,EAAoCU,CAApC,EAAuCwB,KAAvC,EAA8C;AAC5C,QAAM,CAACZ,SAAD,EAAYC,WAAZ,IAA2BvB,IAAI,CAACwB,MAAL,CAAYU,KAAK,CAAC9B,MAAN,GAAe,CAA3B,EAA8BJ,IAAI,CAACI,MAAL,GAAc8B,KAAK,CAAC9B,MAApB,GAA6B,CAA7B,GAAiC,CAA/D,EAAkEqB,KAAlE,CAAwE,GAAxE,CAAjC;AACA,QAAMrB,MAAM,GAAGsB,QAAQ,CAACJ,SAAS,CAACK,IAAV,EAAD,EAAmB,EAAnB,CAAvB,CAF4C,CAEG;;AAE/C,GAAC,GAAG3C,KAAK,CAAC4C,MAAV,EAAkBxB,MAAM,IAAI,IAAV,IAAkBA,MAAM,GAAG,CAAT,KAAe,CAAnD,EAAuD,GAAEJ,IAAK,sBAAqBkC,KAAM,6DAA4D9B,MAAO,EAA5J;AACAvB,EAAAA,KAAK,CAAC0C,WAAN,GAAoBA,WAApB;AACA1C,EAAAA,KAAK,CAACuB,MAAN,GAAeA,MAAf;AACA,SAAOvB,KAAP;AACD;;AAED,SAASsD,UAAT,CAAoBtD,KAApB,EAA2BmB,IAA3B,EAAiC8B,OAAjC,EAA0C;AACxC,SAAOG,aAAa,CAACpD,KAAD,EAAQmB,IAAR,EAAc8B,OAAd,EAAuB,KAAvB,CAApB;AACD;;AAED,SAASM,WAAT,CAAqBvD,KAArB,EAA4BmB,IAA5B,EAAkC8B,OAAlC,EAA2C;AACzC,SAAOG,aAAa,CAACpD,KAAD,EAAQmB,IAAR,EAAc8B,OAAd,EAAuB,MAAvB,CAApB;AACD,C,CAAC;;;AAGF,SAASO,qBAAT,CAA+BxD,KAA/B,EAAsCmB,IAAtC,EAA4CU,CAA5C,EAA+C;AAC7C,QAAM4B,WAAW,GAAG,iBAAiBlC,MAArC;AACAvB,EAAAA,KAAK,CAAC0C,WAAN,GAAoBvB,IAAI,CAACwB,MAAL,CAAYc,WAAW,GAAG,CAA1B,EAA6BtC,IAAI,CAACI,MAAL,GAAckC,WAAd,GAA4B,CAA5B,GAAgC,CAA7D,CAApB;AACA,SAAOzD,KAAP;AACD;;AAED,SAAS0D,UAAT,CAAoBvC,IAApB,EAA0B,CAACwC,KAAD,EAAQC,GAAR,CAA1B,EAAwC;AACtC,MAAIzC,IAAI,CAACwB,MAAL,CAAY,CAAZ,EAAegB,KAAK,CAACpC,MAArB,MAAiCoC,KAArC,EAA4C;AAC1C,WAAO,KAAP;AACD;;AAED,GAAC,GAAGxD,KAAK,CAAC4C,MAAV,EAAkB5B,IAAI,CAAC0C,QAAL,CAAcD,GAAd,CAAlB,EAAuC,aAAYD,KAAM,mBAAkBC,GAAI,QAAOzC,IAAK,EAA3F;AACA,SAAO,IAAP;AACD;;AAED,MAAM2C,gBAAgB,GAAG,CAAC,CAAC,GAAD,EAAM,GAAN,EAAW5D,MAAM,CAACS,WAAP,CAAmBoD,QAA9B,EAAwCxB,eAAxC,CAAD,EAA2D,CAAC,GAAD,EAAM,GAAN,EAAWrC,MAAM,CAACS,WAAP,CAAmBqD,MAA9B,EAAsCpC,aAAtC,CAA3D,EAAiH,CAAC,GAAD,EAAM,GAAN,EAAW1B,MAAM,CAACS,WAAP,CAAmBsD,KAA9B,EAAqCjB,YAArC,CAAjH,EAAqK;AAC9L,CAAC,WAAD,EAAc,GAAd,EAAmB9C,MAAM,CAACS,WAAP,CAAmBuD,QAAtC,EAAgDlB,YAAhD,CADyB,EACsC,CAAC,UAAD,EAAa,GAAb,EAAkB9C,MAAM,CAACS,WAAP,CAAmBwD,OAArC,EAA8CnB,YAA9C,CADtC,EACmG,CAAC,MAAD,EAAS,GAAT,EAAc9C,MAAM,CAACS,WAAP,CAAmByD,GAAjC,EAAsCd,UAAtC,CADnG,EACsJ,CAAC,SAAD,EAAY,GAAZ,EAAiBpD,MAAM,CAACS,WAAP,CAAmB0D,MAApC,EAA4CrB,YAA5C,CADtJ,EACiN,CAAC,OAAD,EAAU,GAAV,EAAe9C,MAAM,CAACS,WAAP,CAAmB2D,IAAlC,EAAwCf,WAAxC,CADjN,EACuQ,CAAC,iBAAD,EAAoB,GAApB,EAAyBrD,MAAM,CAACS,WAAP,CAAmB4D,cAA5C,EAA4Df,qBAA5D,CADvQ,CAAzB;AAEA,MAAMgB,iBAAiB,GAAG,CAAC,CAAC,WAAD,EAAc,GAAd,EAAmBtE,MAAM,CAACS,WAAP,CAAmB8D,QAAtC,CAAD,EAAkD,CAAC,UAAD,EAAa,GAAb,EAAkBvE,MAAM,CAACS,WAAP,CAAmB+D,OAArC,CAAlD,EAAiG,CAAC,UAAD,EAAa,GAAb,EAAkBxE,MAAM,CAACS,WAAP,CAAmBgE,OAArC,CAAjG,EAAgJ,CAAC,SAAD,EAAY,GAAZ,EAAiBzE,MAAM,CAACS,WAAP,CAAmBiE,MAApC,CAAhJ,EAA6L,CAAC,MAAD,EAAS,GAAT,EAAc1E,MAAM,CAACS,WAAP,CAAmBkE,GAAjC,CAA7L,CAA1B;;AAEA,SAASC,cAAT,CAAwB3D,IAAxB,EAA8B,CAACwC,KAAD,EAAQC,GAAR,CAA9B,EAA4C;AAC1C,SAAOzC,IAAI,CAACwB,MAAL,CAAYgB,KAAK,CAACpC,MAAlB,EAA0BJ,IAAI,CAACI,MAAL,GAAcoC,KAAK,CAACpC,MAApB,GAA6BqC,GAAG,CAACrC,MAA3D,CAAP;AACD;;AAED,SAAStB,UAAT,CAAoB8E,KAApB,EAA2B;AACzBrC,EAAAA,WADyB;AAEzBzB,EAAAA;AAFyB,IAGvB,EAHJ,EAGQR,KAAK,GAAG,CAHhB,EAGmB;AACjB;AACA,QAAMU,IAAI,GAAG,CAAC,GAAGf,SAAS,CAAC4E,OAAd,EAAuBD,KAAvB,CAAb;AACA,QAAM/E,KAAK,GAAG;AACZ0C,IAAAA,WADY;AAEZhC,IAAAA,IAAI,EAAER,MAAM,CAACS,WAAP,CAAmBO,KAFb;AAGZD,IAAAA,IAHY;AAIZE,IAAAA;AAJY,GAAd;;AAOA,MAAI,EAAEV,KAAF,KAAYH,UAAhB,EAA4B;AAC1B2E,IAAAA,OAAO,CAACC,IAAR,CAAa,0CAAb;AACA,WAAOlF,KAAP;AACD;;AAED,QAAMmF,MAAM,GAAGrB,gBAAgB,CAACsB,IAAjB,CAAsBD,MAAM,IAAIzB,UAAU,CAACvC,IAAD,EAAOgE,MAAP,CAA1C,CAAf;;AAEA,MAAIA,MAAJ,EAAY;AACVnF,IAAAA,KAAK,CAACU,IAAN,GAAayE,MAAM,CAAC,CAAD,CAAnB;AACA,WAAOA,MAAM,CAAC,CAAD,CAAN,CAAUnF,KAAV,EAAiBmB,IAAjB,EAAuB2D,cAAc,CAAC3D,IAAD,EAAOgE,MAAP,CAArC,EAAqD1E,KAArD,CAAP;AACD;;AAED,QAAM4E,OAAO,GAAGb,iBAAiB,CAACY,IAAlB,CAAuBC,OAAO,IAAI3B,UAAU,CAACvC,IAAD,EAAOkE,OAAP,CAA5C,CAAhB;;AAEA,MAAIA,OAAJ,EAAa;AACXrF,IAAAA,KAAK,CAACU,IAAN,GAAa2E,OAAO,CAAC,CAAD,CAApB;AACArF,IAAAA,KAAK,CAACa,GAAN,GAAYZ,UAAU,CAAC6E,cAAc,CAAC3D,IAAD,EAAOkE,OAAP,CAAf,EAAgC,EAAhC,EAAoC5E,KAApC,CAAtB;AACD;;AAED,SAAOT,KAAP;AACD","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getTypeDef = getTypeDef;\n\nvar _types = require(\"./types\");\n\nvar _util = require(\"@polkadot/util\");\n\nvar _sanitize = _interopRequireDefault(require(\"./sanitize\"));\n\nvar _typeSplit = require(\"./typeSplit\");\n\n// Copyright 2017-2020 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nconst MAX_NESTED = 64; // decode an enum of either of the following forms\n//  { _enum: ['A', 'B', 'C'] }\n//  { _enum: { A: AccountId, B: Balance, C: u32 } }\n\nfunction _decodeEnum(value, details, count) {\n  value.info = _types.TypeDefInfo.Enum; // not as pretty, but remain compatible with oo7 for both struct and Array types\n\n  value.sub = Array.isArray(details) ? details.map(name => ({\n    info: _types.TypeDefInfo.Plain,\n    name,\n    type: 'Null'\n  })) : Object.entries(details).map(([name, type]) => // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  getTypeDef(type || 'Null', {\n    name\n  }, count));\n  return value;\n} // decode a set of the form\n//   { _set: { A: 0b0001, B: 0b0010, C: 0b0100 } }\n\n\nfunction _decodeSet(value, details) {\n  value.info = _types.TypeDefInfo.Set;\n  value.length = details._bitLength;\n  value.sub = Object.entries(details).filter(([name]) => !name.startsWith('_')).map(([name, index]) => ({\n    index,\n    info: _types.TypeDefInfo.Plain,\n    name,\n    type: name\n  }));\n  return value;\n} // decode a struct, set or enum\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\nfunction _decodeStruct(value, type, _, count) {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n  const parsed = JSON.parse(type);\n  const keys = Object.keys(parsed);\n\n  if (keys.length === 1 && keys[0] === '_enum') {\n    return _decodeEnum(value, parsed[keys[0]], count);\n  } else if (keys.length === 1 && keys[0] === '_set') {\n    return _decodeSet(value, parsed[keys[0]]);\n  }\n\n  value.alias = parsed._alias ? new Map(Object.entries(parsed._alias)) : undefined;\n  value.sub = keys.filter(name => !['_alias'].includes(name)).map(name => // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  getTypeDef(parsed[name], {\n    name\n  }, count));\n  return value;\n} // decode a fixed vector, e.g. [u8;32]\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\nfunction _decodeFixedVec(value, type, _, count) {\n  const [vecType, strLength, displayName] = type.substr(1, type.length - 2).split(';');\n  const length = parseInt(strLength.trim(), 10); // as a first round, only u8 via u8aFixed, we can add more support\n\n  (0, _util.assert)(length <= 256, `${type}: Only support for [Type; <length>], where length <= 256`);\n  value.displayName = displayName;\n  value.length = length; // eslint-disable-next-line @typescript-eslint/no-use-before-define\n\n  value.sub = getTypeDef(vecType, {}, count);\n  return value;\n} // decode a tuple\n\n\nfunction _decodeTuple(value, _, subType, count) {\n  value.sub = subType.length === 0 ? [] : (0, _typeSplit.typeSplit)(subType).map(inner => // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  getTypeDef(inner, {}, count));\n  return value;\n} // decode a Int/UInt<bitLength[, name]>\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\nfunction _decodeAnyInt(value, type, _, clazz) {\n  const [strLength, displayName] = type.substr(clazz.length + 1, type.length - clazz.length - 1 - 1).split(',');\n  const length = parseInt(strLength.trim(), 10); // as a first round, only u8 via u8aFixed, we can add more support\n\n  (0, _util.assert)(length <= 8192 && length % 8 === 0, `${type}: Only support for ${clazz}<bitLength>, where length <= 8192 and a power of 8, found ${length}`);\n  value.displayName = displayName;\n  value.length = length;\n  return value;\n}\n\nfunction _decodeInt(value, type, subType) {\n  return _decodeAnyInt(value, type, subType, 'Int');\n}\n\nfunction _decodeUInt(value, type, subType) {\n  return _decodeAnyInt(value, type, subType, 'UInt');\n} // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\nfunction _decodeDoNotConstruct(value, type, _) {\n  const NAME_LENGTH = 'DoNotConstruct'.length;\n  value.displayName = type.substr(NAME_LENGTH + 1, type.length - NAME_LENGTH - 1 - 1);\n  return value;\n}\n\nfunction hasWrapper(type, [start, end]) {\n  if (type.substr(0, start.length) !== start) {\n    return false;\n  }\n\n  (0, _util.assert)(type.endsWith(end), `Expected '${start}' closing with '${end}' on ${type}`);\n  return true;\n}\n\nconst nestedExtraction = [['[', ']', _types.TypeDefInfo.VecFixed, _decodeFixedVec], ['{', '}', _types.TypeDefInfo.Struct, _decodeStruct], ['(', ')', _types.TypeDefInfo.Tuple, _decodeTuple], // the inner for these are the same as tuple, multiple values\n['BTreeMap<', '>', _types.TypeDefInfo.BTreeMap, _decodeTuple], ['HashMap<', '>', _types.TypeDefInfo.HashMap, _decodeTuple], ['Int<', '>', _types.TypeDefInfo.Int, _decodeInt], ['Result<', '>', _types.TypeDefInfo.Result, _decodeTuple], ['UInt<', '>', _types.TypeDefInfo.UInt, _decodeUInt], ['DoNotConstruct<', '>', _types.TypeDefInfo.DoNotConstruct, _decodeDoNotConstruct]];\nconst wrappedExtraction = [['BTreeSet<', '>', _types.TypeDefInfo.BTreeSet], ['Compact<', '>', _types.TypeDefInfo.Compact], ['Linkage<', '>', _types.TypeDefInfo.Linkage], ['Option<', '>', _types.TypeDefInfo.Option], ['Vec<', '>', _types.TypeDefInfo.Vec]];\n\nfunction extractSubType(type, [start, end]) {\n  return type.substr(start.length, type.length - start.length - end.length);\n}\n\nfunction getTypeDef(_type, {\n  displayName,\n  name\n} = {}, count = 0) {\n  // create the type via Type, allowing types to be sanitized\n  const type = (0, _sanitize.default)(_type);\n  const value = {\n    displayName,\n    info: _types.TypeDefInfo.Plain,\n    name,\n    type\n  };\n\n  if (++count === MAX_NESTED) {\n    console.warn('getTypeDef: Maximum nested limit reached');\n    return value;\n  }\n\n  const nested = nestedExtraction.find(nested => hasWrapper(type, nested));\n\n  if (nested) {\n    value.info = nested[2];\n    return nested[3](value, type, extractSubType(type, nested), count);\n  }\n\n  const wrapped = wrappedExtraction.find(wrapped => hasWrapper(type, wrapped));\n\n  if (wrapped) {\n    value.info = wrapped[2];\n    value.sub = getTypeDef(extractSubType(type, wrapped), {}, count);\n  }\n\n  return value;\n}"]},"metadata":{},"sourceType":"script"}