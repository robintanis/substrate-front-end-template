{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = createFunction;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _codec = require(\"@polkadot/types/codec\");\n\nvar _create = require(\"@polkadot/types/create\");\n\nvar _util = require(\"@polkadot/util\");\n\nvar _utilCrypto = require(\"@polkadot/util-crypto\");\n\nvar _getHasher = _interopRequireDefault(require(\"./getHasher\"));\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2.default)(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nconst EMPTY_U8A = new Uint8Array([]);\n\nconst NULL_HASHER = value => value; // with the prefix, method & options, create both the string & raw keys\n\n/** @internal */\n\n\nfunction expandKey({\n  method,\n  prefix\n}, options) {\n  return options.key ? options.key : `${prefix} ${method}`;\n} // get the hashers, the base (and  in the case of DoubleMap), the second key\n\n/** @internal */\n\n\nfunction getHashers({\n  meta: {\n    type\n  }\n}) {\n  if (type.isDoubleMap) {\n    return [(0, _getHasher.default)(type.asDoubleMap.hasher), (0, _getHasher.default)(type.asDoubleMap.key2Hasher)];\n  } else if (type.isMap) {\n    return [(0, _getHasher.default)(type.asMap.hasher)];\n  } // the default\n\n\n  return [(0, _getHasher.default)()];\n} // create a base prefixed key\n\n/** @internal */\n\n\nfunction createPrefixedKey({\n  method,\n  prefix\n}) {\n  return (0, _util.u8aConcat)((0, _utilCrypto.xxhashAsU8a)(prefix, 128), (0, _utilCrypto.xxhashAsU8a)(method, 128));\n} // create a key for a DoubleMap type\n\n/** @internal */\n\n\nfunction createKeyDoubleMap(registry, itemFn, stringKey, args, [hasher1, hasher2]) {\n  const {\n    meta: {\n      name,\n      type\n    }\n  } = itemFn; // since we are passing an almost-unknown through, trust, but verify\n\n  (0, _util.assert)(Array.isArray(args) && !(0, _util.isUndefined)(args[0]) && !(0, _util.isNull)(args[0]) && !(0, _util.isUndefined)(args[1]) && !(0, _util.isNull)(args[1]), `${(name || 'unknown').toString()} is a DoubleMap and requires two arguments`); // if this fails, we have bigger issues\n\n  (0, _util.assert)(!(0, _util.isUndefined)(hasher2), '2 hashing functions should be defined for DoubleMaps');\n  const [key1, key2] = args;\n  const map = type.asDoubleMap;\n  const val1 = (0, _create.createTypeUnsafe)(registry, map.key1.toString(), [key1]).toU8a();\n  const val2 = (0, _create.createTypeUnsafe)(registry, map.key2.toString(), [key2]).toU8a(); // as per createKey, always add the length prefix (underlying it is Bytes)\n\n  return _codec.Compact.addLengthPrefix((0, _util.u8aConcat)(createPrefixedKey(itemFn), hasher1(val1), hasher2(val2)));\n} // create a key for either a map or a plain value\n\n/** @internal */\n\n\nfunction createKey(registry, itemFn, stringKey, arg, hasher) {\n  const {\n    meta: {\n      name,\n      type\n    }\n  } = itemFn;\n  let param = EMPTY_U8A;\n\n  if (type.isMap) {\n    const map = type.asMap;\n    (0, _util.assert)(!(0, _util.isUndefined)(arg) && !(0, _util.isNull)(arg), `${name.toString()} is a Map and requires one argument`);\n    param = (0, _create.createTypeUnsafe)(registry, map.key.toString(), [arg]).toU8a();\n  } // StorageKey is a Bytes, so is length-prefixed\n\n\n  return _codec.Compact.addLengthPrefix((0, _util.u8aConcat)(createPrefixedKey(itemFn), param.length ? hasher(param) : EMPTY_U8A));\n} // attach the metadata to expand to a StorageFunction\n\n/** @internal */\n\n\nfunction expandWithMeta({\n  meta,\n  method,\n  prefix,\n  section\n}, storageFn) {\n  storageFn.meta = meta;\n  storageFn.method = (0, _util.stringLowerFirst)(method);\n  storageFn.prefix = prefix;\n  storageFn.section = section; // explicitly add the actual method in the toJSON, this gets used to determine caching and without it\n  // instances (e.g. collective) will not work since it is only matched on param meta\n\n  storageFn.toJSON = () => _objectSpread(_objectSpread({}, meta.toJSON()), {}, {\n    storage: {\n      method,\n      prefix,\n      section\n    }\n  });\n\n  return storageFn;\n}\n/** @internal */\n\n\nfunction extendHeadMeta(registry, {\n  meta: {\n    documentation,\n    name,\n    type\n  },\n  section\n}, {\n  method\n}, iterFn) {\n  const outputType = type.isMap ? type.asMap.key.toString() : type.asDoubleMap.key1.toString(); // metadata with a fallback value using the type of the key, the normal\n  // meta fallback only applies to actual entry values, create one for head\n\n  iterFn.meta = registry.createType('StorageEntryMetadataLatest', {\n    documentation,\n    fallback: registry.createType('Bytes', (0, _create.createTypeUnsafe)(registry, outputType).toHex()),\n    modifier: registry.createType('StorageEntryModifierLatest', 1),\n    // required\n    name,\n    type: registry.createType('StorageEntryTypeLatest', registry.createType('Type', type.isMap ? type.asMap.key : type.asDoubleMap.key1), 0)\n  });\n  const prefixKey = registry.createType('StorageKey', iterFn, {\n    method,\n    section\n  });\n  return arg => !(0, _util.isUndefined)(arg) && !(0, _util.isNull)(arg) ? registry.createType('StorageKey', iterFn(arg), {\n    method,\n    section\n  }) : prefixKey;\n} // attach the full list hashing for prefixed maps\n\n/** @internal */\n\n\nfunction extendPrefixedMap(registry, itemFn, storageFn) {\n  const {\n    meta: {\n      type\n    }\n  } = itemFn;\n  storageFn.iterKey = extendHeadMeta(registry, itemFn, storageFn, arg => {\n    (0, _util.assert)(type.isDoubleMap || (0, _util.isUndefined)(arg), 'Filtering arguments for keys/entries are only valid on double maps');\n    return type.isDoubleMap && !(0, _util.isUndefined)(arg) && !(0, _util.isNull)(arg) ? new _codec.Raw(registry, (0, _util.u8aConcat)(createPrefixedKey(itemFn), (0, _getHasher.default)(type.asDoubleMap.hasher)(registry.createType(type.asDoubleMap.key1.toString(), arg).toU8a()))) : new _codec.Raw(registry, createPrefixedKey(itemFn));\n  });\n  return storageFn;\n} // attach the full list hashing for double maps\n\n/** @internal */\n\n\nfunction extendDoubleMap(registry, itemFn, storageFn) {\n  return extendPrefixedMap(registry, itemFn, storageFn);\n}\n/** @internal */\n\n\nfunction createFunction(registry, itemFn, options) {\n  const {\n    meta: {\n      type\n    }\n  } = itemFn;\n  const stringKey = expandKey(itemFn, options);\n  const [hasher, key2Hasher] = getHashers(itemFn); // Can only have zero or one argument:\n  //   - storage.system.account(address)\n  //   - storage.timestamp.blockPeriod()\n  // For doublemap queries the params is passed in as an tuple, [key1, key2]\n\n  const _storageFn = arg => type.isDoubleMap ? createKeyDoubleMap(registry, itemFn, stringKey, arg, [hasher, key2Hasher]) : createKey(registry, itemFn, stringKey, arg, options.skipHashing ? NULL_HASHER : hasher);\n\n  const storageFn = expandWithMeta(itemFn, _storageFn);\n\n  if (type.isMap) {\n    extendPrefixedMap(registry, itemFn, storageFn);\n  } else if (type.isDoubleMap) {\n    extendDoubleMap(registry, itemFn, storageFn);\n  }\n\n  storageFn.keyPrefix = arg => storageFn.iterKey && storageFn.iterKey(arg) || (0, _util.compactStripLength)(storageFn())[1];\n\n  return storageFn;\n}","map":{"version":3,"sources":["/home/robin/substrate-front-end-template/node_modules/@polkadot/metadata/Decorated/storage/fromMetadata/createFunction.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","default","createFunction","_defineProperty2","_codec","_create","_util","_utilCrypto","_getHasher","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","EMPTY_U8A","Uint8Array","NULL_HASHER","expandKey","method","prefix","options","getHashers","meta","type","isDoubleMap","asDoubleMap","hasher","key2Hasher","isMap","asMap","createPrefixedKey","u8aConcat","xxhashAsU8a","createKeyDoubleMap","registry","itemFn","stringKey","args","hasher1","hasher2","name","assert","Array","isArray","isUndefined","isNull","toString","key1","key2","map","val1","createTypeUnsafe","toU8a","val2","Compact","addLengthPrefix","createKey","arg","param","expandWithMeta","section","storageFn","stringLowerFirst","toJSON","storage","extendHeadMeta","documentation","iterFn","outputType","createType","fallback","toHex","modifier","prefixKey","extendPrefixedMap","iterKey","Raw","extendDoubleMap","_storageFn","skipHashing","keyPrefix","compactStripLength"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = createFunction;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _codec = require(\"@polkadot/types/codec\");\n\nvar _create = require(\"@polkadot/types/create\");\n\nvar _util = require(\"@polkadot/util\");\n\nvar _utilCrypto = require(\"@polkadot/util-crypto\");\n\nvar _getHasher = _interopRequireDefault(require(\"./getHasher\"));\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nconst EMPTY_U8A = new Uint8Array([]);\n\nconst NULL_HASHER = value => value; // with the prefix, method & options, create both the string & raw keys\n\n/** @internal */\n\n\nfunction expandKey({\n  method,\n  prefix\n}, options) {\n  return options.key ? options.key : `${prefix} ${method}`;\n} // get the hashers, the base (and  in the case of DoubleMap), the second key\n\n/** @internal */\n\n\nfunction getHashers({\n  meta: {\n    type\n  }\n}) {\n  if (type.isDoubleMap) {\n    return [(0, _getHasher.default)(type.asDoubleMap.hasher), (0, _getHasher.default)(type.asDoubleMap.key2Hasher)];\n  } else if (type.isMap) {\n    return [(0, _getHasher.default)(type.asMap.hasher)];\n  } // the default\n\n\n  return [(0, _getHasher.default)()];\n} // create a base prefixed key\n\n/** @internal */\n\n\nfunction createPrefixedKey({\n  method,\n  prefix\n}) {\n  return (0, _util.u8aConcat)((0, _utilCrypto.xxhashAsU8a)(prefix, 128), (0, _utilCrypto.xxhashAsU8a)(method, 128));\n} // create a key for a DoubleMap type\n\n/** @internal */\n\n\nfunction createKeyDoubleMap(registry, itemFn, stringKey, args, [hasher1, hasher2]) {\n  const {\n    meta: {\n      name,\n      type\n    }\n  } = itemFn; // since we are passing an almost-unknown through, trust, but verify\n\n  (0, _util.assert)(Array.isArray(args) && !(0, _util.isUndefined)(args[0]) && !(0, _util.isNull)(args[0]) && !(0, _util.isUndefined)(args[1]) && !(0, _util.isNull)(args[1]), `${(name || 'unknown').toString()} is a DoubleMap and requires two arguments`); // if this fails, we have bigger issues\n\n  (0, _util.assert)(!(0, _util.isUndefined)(hasher2), '2 hashing functions should be defined for DoubleMaps');\n  const [key1, key2] = args;\n  const map = type.asDoubleMap;\n  const val1 = (0, _create.createTypeUnsafe)(registry, map.key1.toString(), [key1]).toU8a();\n  const val2 = (0, _create.createTypeUnsafe)(registry, map.key2.toString(), [key2]).toU8a(); // as per createKey, always add the length prefix (underlying it is Bytes)\n\n  return _codec.Compact.addLengthPrefix((0, _util.u8aConcat)(createPrefixedKey(itemFn), hasher1(val1), hasher2(val2)));\n} // create a key for either a map or a plain value\n\n/** @internal */\n\n\nfunction createKey(registry, itemFn, stringKey, arg, hasher) {\n  const {\n    meta: {\n      name,\n      type\n    }\n  } = itemFn;\n  let param = EMPTY_U8A;\n\n  if (type.isMap) {\n    const map = type.asMap;\n    (0, _util.assert)(!(0, _util.isUndefined)(arg) && !(0, _util.isNull)(arg), `${name.toString()} is a Map and requires one argument`);\n    param = (0, _create.createTypeUnsafe)(registry, map.key.toString(), [arg]).toU8a();\n  } // StorageKey is a Bytes, so is length-prefixed\n\n\n  return _codec.Compact.addLengthPrefix((0, _util.u8aConcat)(createPrefixedKey(itemFn), param.length ? hasher(param) : EMPTY_U8A));\n} // attach the metadata to expand to a StorageFunction\n\n/** @internal */\n\n\nfunction expandWithMeta({\n  meta,\n  method,\n  prefix,\n  section\n}, storageFn) {\n  storageFn.meta = meta;\n  storageFn.method = (0, _util.stringLowerFirst)(method);\n  storageFn.prefix = prefix;\n  storageFn.section = section; // explicitly add the actual method in the toJSON, this gets used to determine caching and without it\n  // instances (e.g. collective) will not work since it is only matched on param meta\n\n  storageFn.toJSON = () => _objectSpread(_objectSpread({}, meta.toJSON()), {}, {\n    storage: {\n      method,\n      prefix,\n      section\n    }\n  });\n\n  return storageFn;\n}\n/** @internal */\n\n\nfunction extendHeadMeta(registry, {\n  meta: {\n    documentation,\n    name,\n    type\n  },\n  section\n}, {\n  method\n}, iterFn) {\n  const outputType = type.isMap ? type.asMap.key.toString() : type.asDoubleMap.key1.toString(); // metadata with a fallback value using the type of the key, the normal\n  // meta fallback only applies to actual entry values, create one for head\n\n  iterFn.meta = registry.createType('StorageEntryMetadataLatest', {\n    documentation,\n    fallback: registry.createType('Bytes', (0, _create.createTypeUnsafe)(registry, outputType).toHex()),\n    modifier: registry.createType('StorageEntryModifierLatest', 1),\n    // required\n    name,\n    type: registry.createType('StorageEntryTypeLatest', registry.createType('Type', type.isMap ? type.asMap.key : type.asDoubleMap.key1), 0)\n  });\n  const prefixKey = registry.createType('StorageKey', iterFn, {\n    method,\n    section\n  });\n  return arg => !(0, _util.isUndefined)(arg) && !(0, _util.isNull)(arg) ? registry.createType('StorageKey', iterFn(arg), {\n    method,\n    section\n  }) : prefixKey;\n} // attach the full list hashing for prefixed maps\n\n/** @internal */\n\n\nfunction extendPrefixedMap(registry, itemFn, storageFn) {\n  const {\n    meta: {\n      type\n    }\n  } = itemFn;\n  storageFn.iterKey = extendHeadMeta(registry, itemFn, storageFn, arg => {\n    (0, _util.assert)(type.isDoubleMap || (0, _util.isUndefined)(arg), 'Filtering arguments for keys/entries are only valid on double maps');\n    return type.isDoubleMap && !(0, _util.isUndefined)(arg) && !(0, _util.isNull)(arg) ? new _codec.Raw(registry, (0, _util.u8aConcat)(createPrefixedKey(itemFn), (0, _getHasher.default)(type.asDoubleMap.hasher)(registry.createType(type.asDoubleMap.key1.toString(), arg).toU8a()))) : new _codec.Raw(registry, createPrefixedKey(itemFn));\n  });\n  return storageFn;\n} // attach the full list hashing for double maps\n\n/** @internal */\n\n\nfunction extendDoubleMap(registry, itemFn, storageFn) {\n  return extendPrefixedMap(registry, itemFn, storageFn);\n}\n/** @internal */\n\n\nfunction createFunction(registry, itemFn, options) {\n  const {\n    meta: {\n      type\n    }\n  } = itemFn;\n  const stringKey = expandKey(itemFn, options);\n  const [hasher, key2Hasher] = getHashers(itemFn); // Can only have zero or one argument:\n  //   - storage.system.account(address)\n  //   - storage.timestamp.blockPeriod()\n  // For doublemap queries the params is passed in as an tuple, [key1, key2]\n\n  const _storageFn = arg => type.isDoubleMap ? createKeyDoubleMap(registry, itemFn, stringKey, arg, [hasher, key2Hasher]) : createKey(registry, itemFn, stringKey, arg, options.skipHashing ? NULL_HASHER : hasher);\n\n  const storageFn = expandWithMeta(itemFn, _storageFn);\n\n  if (type.isMap) {\n    extendPrefixedMap(registry, itemFn, storageFn);\n  } else if (type.isDoubleMap) {\n    extendDoubleMap(registry, itemFn, storageFn);\n  }\n\n  storageFn.keyPrefix = arg => storageFn.iterKey && storageFn.iterKey(arg) || (0, _util.compactStripLength)(storageFn())[1];\n\n  return storageFn;\n}"]},"metadata":{},"sourceType":"script"}